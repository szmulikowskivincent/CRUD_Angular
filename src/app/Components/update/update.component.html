<div id="tout2">
  <form [formGroup]="updateForm" (ngSubmit)="addUpdate()">
    &nbsp;&nbsp;&nbsp;üìÅ
    <button
      style="
        display: inline;
        inline-size: 85px;
        block-size: 30px;
        margin: 10px;
        font-size: 20px;
        color: white;
        background-color: red;
      "
    >
      Delete
    </button>
    &nbsp;
    <button
      style="
        display: inline;
        inline-size: 85px;
        block-size: 30px;
        margin: 10px;
        font-size: 20px;
        color: white;
        background-color: rgb(0, 17, 255);
      "
    >
      Update
    </button>
    &nbsp;&nbsp;
    <input
      type="date"
      id="date"
      formControlName="date"
      placeholder="Date"
      required="true"
      [required]="true"
    />
    <span
      *ngIf="
        updateForm.get('date')?.touched &&
        updateForm.get('dat')?.hasError('required')
      "
    >
      La date est requise.
    </span>
    <span
      *ngIf="
        updateForm.get('date')?.touched &&
        'invalidDate' &&
        updateForm.get('date')?.hasError('required')
      "
    >
      La date n'est pas valide.
    </span>
    <span
      *ngIf="
        updateForm.get('date')?.touched &&
        'dateTooEarly' &&
        updateForm.get('date')?.hasError('required')
      "
    >
      La date doit √™tre apr√®s 2010.
    </span>
    &nbsp;&nbsp;
    <input
      type="text"
      id="nom"
      formControlName="description"
      placeholder="Description"
      minlength="5"
      maxlength="15"
      required="true"
      [required]="true"
    />
    <span
      style="color: red"
      *ngIf="
        updateForm.get('description')?.touched &&
        updateForm.get('description')?.hasError('required')
      "
    >
      La d√©scription est requise.
    </span>
    <span
      style="color: red"
      *ngIf="
        updateForm.get('description')?.touched &&
        updateForm.get('description')?.hasError('minlength')
      "
    >
      La d√©scription doit avoir au moins 5 caract√®res.
    </span>
    <span
      style="color: red"
      *ngIf="
        updateForm.get('description')?.touched &&
        updateForm.get('description')?.hasError('maxlength')
      "
    >
      La description doit avoir au maximum 15 caract√®res.
    </span>
    &nbsp;&nbsp;
    <input
      type="text"
      id="utl"
      formControlName="url"
      placeholder="url//..."
      minlength="10"
      maxlength="55"
      required="true"
      [required]="true"
    />
    <span
      style="color: red"
      *ngIf="
        updateForm.get('url')?.touched &&
        updateForm.get('url')?.hasError('required')
      "
    >
      L' url est requise.
    </span>

    <span
      *ngIf="
        updateForm.get('url')?.hasError('invalidUrl') &&
        updateForm.get('url')?.touched
      "
    >
      L'URL n'est pas valide.
    </span>
    &nbsp;&nbsp;
    <input
      style="
        inline-size: 236px;
        block-size: 35px;
        margin: 8px;
        color: black;
        background-color: white;
        border-radius: 5px;
        border: solid 2.5px rgb(255, 255, 255);
      "
      type="file"
      id="image"
      formControlName="image"
      accept="image/*"
      required="true"
      [required]="true"
    />
    <span
      style="color: red"
      *ngIf="
        updateForm.get('image')?.touched &&
        updateForm.get('image')?.hasError('required')
      "
    >
      L'image est requise.
    </span>
    &nbsp;&nbsp;
    <button type="submit" [disabled]="" (click)="addToMyList()">Update</button>
    <button
      style="
        text-align: center;
        border: 2px solid #757474;
        background-color: rgb(255, 0, 0);
        border: none;
        color: #ffffff;
        font-size: 20px;
        margin: 40px;
        inline-size: 1440px;
        border-radius: 5px;
      "
      class="button"
      type="reset"
    >
      Reset
    </button>
    <ul>
      <li *ngFor="let update of updates" class="update-item">
        üìÅ&nbsp;&nbsp;
        <button
          class="button"
          style="
            inline-size: 85px;
            block-size: 30px;
            font-size: 20px;
            color: white;
            background-color: red;
          "
          (click)="removeUpdate(update.id)"
        >
          Delete
        </button>
        &nbsp; &nbsp; &nbsp;
        <button
          class="button"
          style="
            inline-size: 85px;
            block-size: 30px;
            font-size: 20px;
            color: white;
            background-color: rgb(0, 17, 255);
          "
          (click)="removeUpdate(update.id)"
        >
          Update
        </button>
        &nbsp; &nbsp; Date: &nbsp; {{ update.date | date : "medium" }} - &nbsp;
        Ressource:{{ update.description }} - URL: &nbsp;<a
          href="{{ update.url }}"
          class="url-link"
          target="_blank"
          >{{ update.url }} - {{ update.image }}</a
        >
        ‚≠ê
        <!-- Ajouter la textarea ici -->
        <textarea
          style="
            display: block;
            inline-size: 97.5%;
            block-size: 100px;
            margin-block-start: 10px;
            font-size: 16px;
          "
        >
Angular
        COGNITIC
        Table des mati√®res
        1. Introduction
        2. Projet Angular
        3. Binding
        4. Pipes
        5. Directives
        6. @Input / @Output
        7. Services et Injection
        8. Formulaires
        9. Routing
        10. Storage
        11. Observable
        12. HttpClient
        13. Publication
        2
        COGNITIC
        1. Introduction
        3
        COGNITIC
        Table des mati√®res
        4
        Introduction
        1.1 Angular ? C‚Äôest quoi ?
        1.2 Avantages / Inconv√©nients
        1.3 NodeJS
        1.4 Typescript
        1.5 Installation
        1.6 Outils
        COGNITIC
        1.1 Angular ? C‚Äôest quoi ?
        
        5
        Angular est un framework de d√©veloppement front-end mis
        en place par Google et bas√© sur Javascript (au travers de
        NodeJS et Typescript)
        Il permet de mettre en place des SPA (Single Page
        Application). Autrement dit : la navigation entre les ‚Äúpages‚Äù
        semble invisible pour l‚Äôutilisateur. Il a l‚Äôimpression de rester
        constamment sur la m√™me page puisqu‚Äôil n‚Äôy a pas de
        rechargement de l‚Äôint√©gralit√© du site d‚Äôune page √† l‚Äôautre.
        La premi√®re version du framework date de 2016 et se met √†
        jour r√©guli√®rement pour r√©pondre aux attentes du monde
        professionnel.
        https://angular.io/
        COGNITIC
        1.2 Avantages / Inconv√©nients
         Pour
        - Framework complet pour le front
        - Injection de d√©pendances
        - Compilation rapide
        - Documentation compl√®te et
        simple
        - Evolue constamment
        - Mod√®le proche du MVVM
        - Avantage du Typescript
        6
         Contre
        - Lourdeur de la syntaxe
        - Pas d‚Äôacc√®s direct √† une DB
        - Migration d‚Äôune version √† l‚Äôautre
        probl√©matique (les librairies
        mettent du temps √† suivre)
        - Courbe d‚Äôapprentissage √©norme
        COGNITIC
        1.3 NodeJS
        7
        En quelques mots : NodeJS est un environnement
        back-end d√©velopp√© en Javascript sur base de la
        machine virtuelle V8, moteur d‚Äôex√©cution JS (qui se
        cache dans Chrome).
        Il permet de mani√®re tr√®s l√©g√®re, de mettre en place
        des APIs (gr√¢ce √† Express) et permet l'ex√©cution du
        Javascript c√¥t√© serveur.
        Il est associ√© √† un gestionnaire de paquet - NPM -
        qui fonctionne via un terminal et permet d‚Äôajouter
        des d√©pendances tel que Angular, √† un projet. https://nodejs.org/en/
        COGNITIC
        1.4 Typescript
        8
        Il s‚Äôagit d‚Äôun langage d√©velopp√© par Microsoft pour
        faciliter et ‚Äús√©curiser‚Äù la production de code
        Javascript.
        Typescript est en r√©alit√© une surcouche du JS. Ce qui
        signifie que tout code JS est un code Typescript
        valide.
        Il apporte les notions de programmation orient√©
        objet et de typage statique des variables qui font
        cruellement d√©faut √† Javascript pour en faire un
        langage beaucoup plus structur√© et facile d‚Äôacc√®s.
        https://www.typescriptlang.org/
        COGNITIC
        1.5 Installation d‚ÄôAngular
        1. Installer NodeJS (prendre la version LTS sur le site officiel)
        2. Installer Angular en ligne de commande (WIN+R => CMD)
        npm install -g @angular/cli
        Le param√®tre -g permet une installation globale au niveau du syst√®me et pas
        uniquement dans le dossier ou vous vous situez
        3. V√©rifier que l‚Äôinstallation est bien termin√©e en tapant
        ng version
        9
        COGNITIC
        1.6 Outils
        L‚Äô√©diteur utilis√© dans le cadre du cours sera Visual Studio Code
        https://code.visualstudio.com/
        Il permettra d‚Äôinstaller des plug-ins sp√©cifiques √† Angular :
        - Angular Schematics => ex√©cution de commande via un menu contextuelle
        - Angular Snippets
        - Angular Language Service
        Les deux suivants am√®nent des aides au code comme l‚Äôauto compl√©tion ou des
        raccourcis d‚Äô√©criture.
        10
        COGNITIC
        2. Projet Angular
        11
        Mise en place
        COGNITIC
        Table des mati√®res
        12
        Projet Angular
        2.1 Cr√©ation du projet
        2.2 Arborescence
        2.3 Les Modules
        2.4 Cr√©ation de module
        2.5 Les Composants
        2.6 Cycle de vie des composants
        2.7 Intro √† la navigation
        COGNITIC
        2.1 Commandes et options
        - ng new ‚Äúnom_du_projet‚Äù => Cr√©e un dossier ‚Äúnom_du_projet‚Äù en y copiant tout
        ce qui est n√©cessaire au framework
         Options
        13
        --skip-tests D√©sactive la copie des fichiers de test unitaires
        --routing Ajoute le routage √† l‚Äôapplication
        --strict (true/false) Utilisation du mode strict qui force l‚Äôinitialisation des
        variables/propri√©t√© dans le constructeur
        --skip-git D√©sactive l‚Äôinitialisation par d√©faut du d√©p√¥t Git
        Liste des options : https://angular.io/cli/new
        COGNITIC
        2.1b Installation du projet
        Une fois la commande basique ex√©cut√©e (ng new ‚Äúprojet‚Äù), le syst√®me vous posera 2
        questions
        1. Ajouter angular routing ? => r√©pondre oui
        2. Mode de template css ? => choisir SCSS (pour plus de compatibilit√© avec les
        diff√©rents framework/librairie graphiques)
        Ces questions peuvent √™tre √©vit√©es en ajoutant les options ad√©quates √† la commande
        de base.
        14
        COGNITIC
        2.1c D√©marrer le serveur -- NG SERVE
        La commande - ng serve - compile et d√©marre l‚Äôapplication sur le port 4200 (par d√©faut).
        Dans le cas o√π vous auriez plusieurs applications qui tournent en parall√®le, il est
        possible de modifier le port de l‚Äôapp
        ng serve --port=42XX
        L‚Äôoption --open ouvre l‚Äôapp dans le navigateur par d√©faut une fois celle ci compil√©e
        Une fois compil√©e et d√©marr√©e, l‚Äôapplication pourra √™tre modifi√©e sans avoir √† relancer le
        serveur. Le processus ‚ÄúAhead-of-time‚Äù se charge de recompil√© en direct l‚Äôapplication √†
        chaque sauvegarde de fichier.
        15
        COGNITIC
        2.2 Arborescence du projet
        Les diff√©rents dossiers et fichiers importants
        16
        Fichier/dossier Utilit√©
        /e2e Dossier r√©serv√© aux tests end user
        /node_modules Contient tout les modules n√©cessaire au fonctionnement du framework, ainsi que les
        module ajout√© par la suite ( => ne pas toucher !!! )
        /src Dossier principal de d√©veloppement. C‚Äôest l√† qu‚Äôon va travailler
        angular.json Configuration du workspace et du projet
        package.json Liste et version des packages utilis√©s dans le projet
        tsconfig.json Configuration de la compilation Typescript
        tslint.json Configuration permettant la v√©rification du code √† chaud sans le compiler
        COGNITIC
        2.2 Arborescence du projet
        D√©tails du dossier /src
        17
        Fichier/dossier Utilit√©
        /app C‚Äôest la que l‚Äôapplication prend vie. On y int√©grera nos pages ainsi que leur logique
        /assets Contiendra les √©ventuelles m√©dia suppl√©mentaires (images, sons, vid√©os)
        n√©cessaires √† l‚Äôapplications
        /environments Permettra de localiser les variables d‚Äôenvironnement tel que les adresses d‚Äô API
        index.html Point d‚Äôentr√©e de l‚Äôapplication. Contiendra les imports css/js √©ventuelles
        styles.scss Feuille de style par d√©faut de l‚Äôapplication
        main.ts Permet de d√©finir le module de d√©marrage le l‚Äôapp (laisser par d√©faut de pr√©f√©rence)
        COGNITIC
        2.3 app module
        La programmation Angular est dite ‚ÄúModulaire‚Äù ce qui signifie que nous allons mettre en place plusieurs
        modules et les faires communiquer entre eux. Nous verrons cela plus tard. Attardons nous sur le module
        principale de notre application. Celui cr√©√© par d√©faut lors de la cr√©ation d‚Äôun projet et qui sera le point
        d‚Äôentr√©e de notre app
        18
        Il s‚Äôagit du root module (module parent) qui englobe toute l‚Äôapplication.
        Il propose son propre routage, il s‚Äôagit √©galement du point d‚Äôentr√©e vers
        les diff√©rentes logiques, fonctionnelle et visuelle, de votre application
        Pour des raisons pratiques, nous ferons l‚Äôimpasse sur tous les fichiers suffix√©s .spec.ts . Ces fichiers
        √©tant r√©serv√©s aux tests unitaires.
        COGNITIC
        2.3 app.module.ts
        Le fichier app.module.ts repr√©sente la configuration du module principal et propose diff√©rentes parties
        que nous allons d√©taill√©s ici
        19
        Le d√©corateur @NgModule signifie au syst√®me que le fichier est le point
        d‚Äôentr√©e du module et permet d‚Äôapporter une structure √† celui ci
        declarations : [] => Nous y d√©clarons le/les composants utilis√©(s) par le module
        imports : [] => Contient les diff√©rents modules import√©s et utilis√©s par celui en cours
        exports : [] => Permet d‚Äôexporter tout ou partie des modules/composants utilis√© par
        celui en cours
        providers : [] => Contiendra des informations pour l‚Äôinjection de d√©pendances
        bootstrap : [] => Le composant d‚Äôamor√ßage du module (si composant il y a)
        export class AppModule { } => signifie simplement que le module est export√© et
        donc importable ailleurs dans l‚Äôapplication
        COGNITIC
        2.4 Module => cr√©ation
        20
        Un module contiendra d‚Äôoffice un fichier ‚Äúnom.module.ts‚Äù. Qui, √† l‚Äôinstar du app.module.ts contiendra le
        d√©corateur @ngModule.
        ng g m nom_du_module => cr√©e un nouveau module
        Aucune obligation n‚Äôexiste quand √† la pr√©sence d‚Äôun composant ou d‚Äôun routing sp√©cifique dans un
        nouveau module (exception faite pour le AppModule)
        Il est n√©anmoins possible de cr√©er un composant √† inclure directement dans un module.
        ng g c nom_du_composant -m nom_du_module
        Ajouter l‚Äôoption --routing pour inclure ‚Äúnom-routing.module.ts‚Äù au module d√©s sa cr√©ation
        COGNITIC
        2.5 Component
        Notre module principale, en plus d‚Äôint√©grer un routing (que nous d√©taillerons plus tard), et un fichier de
        configuration (app.module.ts), int√®gre un component compos√© de 3 fichiers
        - app.component.html => Template visuel
        - app.component.scss => Feuille de style
        - app.component.ts => Code behind en typescript
        Un component est l‚Äôunit√© de travail en Angular. Autrement dit, nos pages seront bas√©es sur des
        components. Chacun √©tant compos√© de ces 3 fichiers (html/css/ts)
        ng generate component ‚Äúnom_du_composant‚Äù|| ng g c ‚Äúnom_du_composant‚Äù
        ==> Commande de cr√©ation d‚Äôun nouveau composant
        21
        COGNITIC
        2.5 Component => TS
        C‚Äôest ici que nous mettrons en place toute la logique des composants au travers du code Typescript.
        Ce fichier est compos√© d‚Äôun d√©corateur @Component et d‚Äôune classe compl√®te avec son constructeur et
        ses imports.
        22
        Les imports repr√©sentent tout mod√®les, modules ou
        services n√©cessaires au fonctionnement du composant.
        C‚Äôest dans la classe que nous int√©grerons la logique
        fonctionnelle (propri√©t√©s, m√©thodes, constructeur, ...)
        COGNITIC
        2.5 Component => TS
        23
        Le d√©corateur d√©crit 3 propri√©t√©s du composant
        - selector => Permet d‚Äôint√©grer ce
        composant dans n‚Äôimporte quelle page
        html
        - templateUrl => Url de la page html li√©e au
        composant
        - styleUrls => Url de la feuille de style du
        composant
        Exemple d‚Äôappel par s√©lecteur
        Fichier TS
        Fichier HTML
        COGNITIC
        2.5 Component => HTML
        Le fichier.html d‚Äôun component contiendra comme son extension l‚Äôindique, du code
        HTML principalement. Mais aussi divers choses qui nous viennent du framework
        Angular :
        - Directives
        - Bindings
        - Pipes
        Qui seront bien √©videment vues en d√©tails dans les chapitres d√©di√©s
        24
        COGNITIC
        2.6 Intro aux cycles de vie des composants
        Le cycles de vie d‚Äôun composant (Hooks) repr√©sente les diff√©rents instants de son existence. Chacun
        d‚Äôeux, demande que la classe du composant impl√©mente l‚Äôinterface n√©cessaire √† son fonctionnement
        OnInit => Ex√©cute le contenu de la m√©thode ngOnInit() √† l‚Äôinitialisation du composant
         Ne s'ex√©cute qu‚Äôune seule fois au premier appel du composant
        25
        COGNITIC
        2.6 Intro aux cycles de vie des composants (suite)
        OnDestroy => Ex√©cute le contenu de la m√©thode ngOnDestroy() √† la destruction du composant
         Permet de lib√©rer la m√©moire √† la destruction du composant (d√©sinscription aux
         Observables, fermeture de connexion √©ventuelle, ‚Ä¶)
        26
        COGNITIC
        2.6 Intro aux cycles de vie des composants (fin)
        Les deux hooks pr√©sent√©s pr√©c√©demment sont les plus fr√©quemment utilis√©s. OnInit
        est d‚Äôailleurs impl√©ment√© de base √† la cr√©ation d‚Äôun nouveau composant.
        Il en existe bien d‚Äôautres qui peuvent √™tre utiles √† diff√©rents moments du
        d√©veloppement. Ils sont d√©taill√©s dans la doc officielle d‚ÄôAngular
        https://angular.io/guide/lifecycle-hooks
        27
        COGNITIC
        2.7 Les bases de la navigation
        Il est n√©cessaire de sp√©cifier les routes d‚Äôacc√®s √† nos composants pour pouvoir naviguer de mani√®re fluide. Nous
        utilisons les ‚Äúrouting-module‚Äù pour se faire.
        28
        app-routing.module.ts HTML
        L‚Äôutilisation de l‚Äôattribut ‚ÄúHREF‚Äù implique un rechargement complet du site visible √† l‚Äôoeil nu, ce qui va √† l‚Äôencontre du principe de
        Single Page App.
        L‚Äôattribut ‚ÄúROUTERLINK‚Äù offre un chargement invisible. En r√©alit√©, seul le composant appel√© par le routing est charg√© √† l‚Äôendroit
        ou se trouve la balise <router-outlet></router-outlet> dans le template HTML
        COGNITIC
        2.7 Les bases de la navigation
        29
        Gr√¢ce √† la propri√©t√© ‚Äúchildren‚Äù, il est possible de d√©finir des
        liens enfants, qui pourrait correspondre √† une architecture
        Dossier/Sous-dossier.
        Pour rendre ceci fonctionnel, il ne faudra pas oublier
        d‚Äôajouter <router-outlet></router-outlet> au niveau du
        composant parent (HomeCompenent)
        L‚Äôexemple pr√©c√©dent donne lieu √† l‚Äôurl :
        http://localhost:4200/home/demo
        COGNITIC
        2.7 Les bases de la navigation
        Dans le cas d‚Äôune navigation inter-module, il
        sera n√©cessaire d‚Äôimporter le routing des
        modules secondaires au niveau du module
        principal de l‚Äôapplication pour que celui ci ait
        acc√®s aux routes d√©clar√©es dans les autres.
        30
        Il faut √©galement d√©clarer le lien vers le
        nouveau module dans le routing du
        AppModule.
        Nous utilisons cette m√©thode pour cr√©er un
        Lazy Loading entre les modules. Ce qui veut
        dire que les sous modules et leur
        composants ne seront charg√©s qu‚Äô√† la
        demande et pas directement au lancement
        de l‚Äôapplication.
        Nous choisissons le Lazy-Loading Vs le Eager-Loading
        pour des questions de performances
        COGNITIC
        Exercice
        Mettre en place 2 nouveaux modules (Demo et Exercice). Comprenant chacun un composant
        d‚Äôamor√ßage et un routing sp√©cifique.
        Cr√©er un composant de navigation et l‚Äôinclure au template de base (menu √† droite de la page)
        Tous les composants et modules doivent √™tre accessible √† partir de la page d'accueil de
        l‚Äôapplication
        31
        COGNITIC
        3. Bindings
        32
        COGNITIC
        Table des mati√®res
        33
        Bindings
        3.1 Property Binding
        3.2 Event Binding
        3.3 Attribute Binding
        COGNITIC
        3.1 Property bindings
        Le property-binding cr√©e une liaison entre une propri√©t√© Typescript et le template HTML. Il s‚Äôagit
        de faire interagir les 2 fichiers de mani√®res √† apporter un certain dynamisme √† nos pages.
        Il existe 2 types de property-binding :
        - One-way => lecture du contenu d‚Äôune propri√©t√© dans le template visuel
        - Two-way => liaison montante et descendante d‚Äôune propri√©t√©
        (Les propri√©t√©s d√©clar√©e dans le fichier .TS sont par d√©faut public. Il est possible de changer cette accessibilit√©,
        mais une propri√©t√© ‚Äúprivate‚Äù ne pourra pas √™tre accessible dans la page HTML)
        34
        COGNITIC
        3.1 Property bindings : exemple
        35
        Typescript Html
        One Way
        Two Way
        Si la valeur de maVariable est modifi√©e de
        quelque mani√®re que ce soit (ts ou html),
        la mise √† jour se fait en temps r√©el des deux
        c√¥t√©s sans rafraichir la page.
        Il est n√©cessaire d‚Äôimporter FormsModule
        au niveau du module pour que [(ngModel)]
        soit disponible
        COGNITIC
        3.2 Event Binding
        L‚Äôevent binding permet de lier un √©v√©nement JS (ex : onClick, onChange, onFocus,....) du template
        HTML √† une m√©thode d√©finie dans le typescript.
        36
        Il est √©videmment possible de passer des param√®tres √† notre m√©thode
        COGNITIC
        3.3 Attribute Binding
        Il est possible de conditionner l‚Äôapparition d‚Äôun attribut gr√¢ce √† une expression
        bool√©enne dans l‚Äôhtml.
        37
        Il est √©galement possible de lier l‚Äôattribut √† une propri√©t√©
        TS HTML
        COGNITIC
        4. Pipes
        38
        COGNITIC
        Table des mati√®res
        39
        Les Pipes
        4.1 Les pipes. Comment √ßa marche ?
        4.2 Les principaux pipes
        4.3 Custom Pipe
        COGNITIC
        4.1 Les pipes - Comment √ßa marche ?
        40
        Les pipes permettent de formater ou transformer l‚Äôaffichage d‚Äôune propri√©t√© dans un binding.
        Le nom ‚Äúpipe‚Äù vient du caract√®re utilis√© pour y faire appel
        SALUT LES GARS !
        TypeScript
        HTML
        Navigateur
        COGNITIC
        4.2 Les principaux pipes
        41
        Pipe Utilit√©
        | date(‚Äòformat‚Äô) Formate l‚Äôaffichage de la date
        | uppercase Transforme la cha√Æne en majuscule
        | lowercase Transforme la cha√Æne en minuscule
        | titlecase Le premier caract√®re de chaque mot en majuscule
        | currency Prend une devise en param√®tre (EUR/USD/‚Ä¶)
        | json Convertit la valeur en cha√Æne Json (utile pour le d√©buggage)
        Il s‚Äôagit des principaux pipes utilis√©s : Liste compl√®te sur la doc officielle
        COGNITIC
        4.3 Les custom pipes
        Il est possible de cr√©er des pipes custom permettant de r√©pondre √† nos attentes pr√©cises comme
        des conversion de valeur, format d‚Äôaffichage sp√©cifique ou tout autre besoin rencontr√©.
        ng g pipe nom_du_pipe
        42
        Le d√©corateur @Pipe permet de
        d√©finir le nom d‚Äôappel du pipe
        La classe ainsi cr√©√©e impl√©mente l‚Äôinterface PipeTransform
        COGNITIC
        4.3 Les custom pipes
        Il est possible de d√©finir nos propres param√®tres pour notre pipes. Il demande de d√©finir la
        m√©thode transform()
        43
        Le premier param√®tre(value : unknown)
        repr√©sente la propri√©t√© sur laquelle le pipe
        va √™tre appliqu√©. Il est bien entendu que
        les types doivent correspondre.
        Le second (...args: unknown[]), tous les
        param√®tres suppl√©mentaires √©ventuels qui
        pourraient accompagner le pipe
        En dernier lieu, il sera n√©cessaire de
        d√©finir le type de retour de notre pipe
        1 2
        3
        COGNITIC
        4.3 Les custom pipes (Probl√®me)
        44
        ng g m Shared
        Nous rencontrons d√®s lors un probl√®me
        d‚Äôimport au niveau de nos diff√©rents
        modules.
        Le syst√®me vous signifie que votre pipe
        n‚Äôest pas inclu/trouv√© par le module Demo.
        Il faut recourir au subterfuge du
        ‚ÄúSharedModule‚Äù.
        Autrement dit : un module qui servira de
        passerelle pour vos diff√©rents pipes, directives,
        services ou composants communs et partag√©s
        entre diff√©rents modules. Ce module devra √™tre
        import√© dans chaque module ou vos √©l√©ments
        communs doivent se retrouver
        SharedModule DemoModule
        COGNITIC
        Exercice
        Mettre en place un chronom√®tre
        - 3 Boutons : Start, Pause, Reset (actif/inactif en fonction des besoins)
        - Affichage ‚Äúxx minutes xx secondes‚Äù
        Astuce : cherchez du c√¥t√© de setInterval() et du string Interpolation de Typescript ;)
        45
        COGNITIC
        5 Les directives
        46
        COGNITIC
        Table des mati√®res
        47
        Les directives
        5.1 C‚Äôest quoi une directive ?
        5.2 Components Directives
        5.3 Structural Directives
        5.4 Custom Directive
        COGNITIC
        5.1 C‚Äôest quoi une directive ?
        48
        Il en existe diff√©rents types, et la possibilit√© d‚Äôen cr√©er sois-m√™me.
        - Directive de composants (NgClass, NgStyle, NgModel)
        - Directive Structurelle (NgIf, NgFor, NgSwitch)
        - Directive d‚Äôattributs (custom directive)
        Les directives sont des classes qui ajoutent un
        comportement suppl√©mentaire aux √©l√©ments de
        vos applications Angular. Avec les Built-in
        directives d'Angular, vous pouvez g√©rer les listes,
        les styles et ce que voient les utilisateurs.
        Elles s‚Äôappliquent sur des composants/balises html
        pour en conditionner l‚Äôaffichage
        COGNITIC
        5.2 Component Directives
        Elles permettent de ‚Äútoucher‚Äù √† l‚Äôaffichage de votre page.
        - NgStyle (permet d‚Äôajouter du code CSS inline √† vos balises)
        - NgClass (ajoute une classe CSS en fonction d‚Äôune expression bool√©enne)
        - NgModel (Comme d√©j√† vu, permet le binding two-way d‚Äôune propri√©t√©)
        49
        COGNITIC
        5.3 Structural directives
        Permettent d‚Äôint√©grer des structures conditionnelle dans votre template visuel.
        - NgIf (Conditionne l‚Äôaffichage de contenu sur base d‚Äôune expression bool√©enne)
        - NgFor (Permet de r√©p√©ter un affichage n fois. Sert principalement √† parcourir des
        collections)
        - NgSwitch (Permet des structure conditionnelle type Switch/case comme son nom
        l‚Äôindique)
        50
        COGNITIC
        5.4 Custom Directives
        La cr√©ation de custom directive se fait via la commande :
        ng g directive nom_de_la_directive
        51
        Il est n√©cessaire, comme pour les
        pipes, de d√©clarer la directive dans
        le module qui l‚Äôutilisera
        COGNITIC
        5.4 Custom Directives
        52
        Le d√©corateur @HostListener ‚Äú√©coute‚Äù ce
        qu‚Äôil se passe et r√©agit en fonction de l‚Äô
        √©v√®nement pr√©cis√© entre ( )
        L‚Äôutilisation par injection de ElementRef permet
        d‚Äôacc√©der √† l‚Äô√©l√©ment ‚Äúel‚Äù appelant la directive
        COGNITIC
        Exercice
        Sur base d‚Äôun mod√®le Link, mettre en place un menu de navigation r√©actif en fonction
        d‚Äôune liste de lien d√©finie dans le TS de nav-component
        - Chaque module sera repr√©sent√© dans le menu (Demo, Exercices) et sera l‚Äôoccasion
        d‚Äôun sous-menu affich√©e/cach√©e sur un click
        6. @Input @Output
        54
        Discussion entre composants
        COGNITIC
        Table des mati√®res
        55
        @Input @Output
        6.1 Faire discuter les composant
        6.2 @Input
        6.3 @Output
        COGNITIC
        6.1 Faire discuter les composants
        Nous avons pr√©c√©demment vu qu‚Äôil est possible d‚Äôint√©grer un composant √† un
        autre gr√¢ce √† l‚Äôappel par s√©lecteur.
        Il nous est, par cons√©quent, possible de cr√©er un dialogue entre le composant
        appelant (parent) et le composant appel√© (enfant) en nous servant
        principalement du s√©lecteur et des d√©corateurs @Input et @Output
        D‚Äôenvoyer des informations du parent √† l‚Äôenfant au travers de propri√©t√©s.
         Et de faire r√©agir le parent en fonction de ce qu‚Äôil se passe dans l‚Äôenfant via des
        EventEmitter
        56
        COGNITIC
        6.2 @Input
        Gr√¢ce au d√©corateur @Input , l‚Äôenfant est en mesure de recevoir une information
        transmise par son parent.
        57
        Appel par s√©lecteur du c√¥t√© parent en d√©finissant
        une propri√©t√© √† transmettre √† l‚Äôenfant
        R√©cup√©ration et utilisation de la propri√©t√© dans le
        composant enfant
        TS
        HTML
        Le d√©corateur @Input doit √™tre importer de @angular/core
        COGNITIC
        6.3 @Output
        Le d√©corateur @Output permet de d√©finir une r√©ponse de l‚Äôenfant vers le parent au
        travers d‚Äôun EventEmitter que nous mettrons en place.
        58
        Mise en place de l‚ÄôEventEmitter c√¥t√© enfant. Son
        nom fera office de ‚Äútype d‚Äô√©v√®nement‚Äù utilisable
        du c√¥t√© parent
        Event Binding c√¥t√© parent pour r√©cup√©rer la
        r√©ponse de l‚Äôenfant au travers de l‚ÄôEvent mis en
        place dans ce dernier
        Le d√©corateur @Output et EventEmitter doivent √™tre importer de @angular/core
        COGNITIC
        6.4 NgContent
        Du contenu peut √™tre d√©fini dans le parent pour l‚Äôenfant. Et afficher dans l‚Äôenfant via le
        s√©lecteur <ng-content></ng-content>
        59
        COGNITIC
        Exercice
        Mettre en place une shopping list en deux composant.
        Dans le premier, un champ texte permettant l‚Äôajout d‚Äôun article √† la liste
        Dans le deuxi√®me, l‚Äôaffichage de la liste et la possibilit√© de supprimer un article.
        Les deux composant doivent √™tre afficher sur la m√™me page
        60
        COGNITIC
        7 Service et Injection
        61
        COGNITIC
        Table des mati√®res
        62
        Les services
        7.1 Pourquoi et comment ?
        7.2 Injection de d√©pendances
        COGNITIC
        7.1 Les services pourquoi et comment
        63
        Les services permettent de regrouper des fonctionnalit√©s li√©es entre elles (comme la
        consommation d‚Äôun end-point d‚ÄôAPI) pour une meilleure maintenabilit√©.
        Ou encore des fonctionnalit√©s partag√©es par toute l‚Äôapplication (ex : la gestion des r√¥les utilisateur
        ou des m√©thodes de calcul) => Grand potentiel de r√©utilisabilit√©
        Ils peuvent √©galement fournir √† un module ou un composant les outils n√©cessaires √† leur
        fonctionnement
        En bref, ils constituent le coeur de la logique fonctionnelle de l‚Äôapplication.
        Et atout non n√©gligeables, ils b√©n√©ficient de l‚Äôinjection de d√©pendances native en Angular.
        COGNITIC
        7.1 Les services pourquoi et comment
        Cr√©er un service : ng g s dossier/nom_du_service
        64
        Le d√©corateur @Injectable signifie que la classe est
        injectable en tant que service.
        Le param√®tres ProvidedIn est sp√©cifique √† l‚Äôinjection
        de d√©pendances.
        COGNITIC
        7.2 Injection de d√©pendances
        Il s‚Äôagit d‚Äôun design pattern laissant
        l‚Äôapplication d√©cid√© de la nouvelle
        instanciation d‚Äôune classe de service ou de
        l‚Äôutilisation de l‚Äôinstance existante.
        Le framework Angular embarque l‚Äôinjection
        de d√©pendance de mani√®re native. Et nous
        permet de d√©finir la port√©e de nos
        instances (module, composant,
        application). Il nous faudra d√®s lors d√©finir
        deux choses : Le provider du service et ou
        injecter ce dernier.
        65
        Du provider d√©pend la port√©e et la dur√©e de vie
        de l‚Äôinstance du service. Une fois d√©fini (voir
        slide suivant), nous utiliserons l‚Äôinjection par
        constructeur pour injecter notre service
        COGNITIC
        7.2 Injection de d√©pendances
        66
        Provider Port√©e et dur√©e de vie Mise en place
        Component L‚Äôinstance n‚Äôest disponible que durant la vie du composant.
        (voir Cycle de vie) Et uniquement dans le composant (et ses
        enfants) Une nouvelle instance du service sera instanci√©e √†
        chaque appel de constructeur du composant
        A d√©finir dans le tableau providers de
        @Component
        Module
        eager-loaded
        (Singleton)
        Disponible pour toute l‚Äôapplication d√®s son lancement Le param√®tre providedIn de @Injectable d√©finit le
        provider du service ‚Äòroot‚Äô ou ‚Äònom_du_module‚Äô
        Ou dans le tableau providers de @NgModule
        Module
        lazy-loaded
        (Singleton)
        Disponible √† partir du moment ou le module est charg√©. Peut
        causer des erreurs s‚Äôil est inject√© avant que le module ne soit
        charg√©
        Root Module
        (Singleton)
        Disponible pour toute l‚Äôapplication d√®s son lancement
        COGNITIC
        Exercice
        Optimiser la liste de course avec l‚Äôutilisation d‚Äôun service qui g√®re la liste et les
        m√©thodes qui peuvent s‚Äôy appliquer
        Ajouter la possibilit√© de g√©rer le nombre d‚Äôarticles voulu (Ex : Lait x 6, Tomates x 3, ‚Ä¶)
        67
        COGNITIC
        8 Formulaires
        68
        COGNITIC
        Table des mati√®res
        69
        Les formulaires
        8.1 Les diff√©rents formulaires
        8.2 FormBuilder
        8.3 FormControl
        8.4 FormGroup
        8.5 FormArray
        8.6 Validators
        8.7 Validation de formulaire
        8.8 R√©cup√©ration des donn√©es
        8.9 Custom Validator
        COGNITIC
        8.1 Les diff√©rents formulaires
        70
        La plupart des interactions utilisateur se font au travers de formulaires. Nous avons deux
        options √† notre port√©e.
        - Template-driven Forms => Input li√© √† une propri√©t√© par Two-way binding.
        Rappel : Il faut importer FormsModule au niveau du module ou de l‚Äôapp
        - Reactive Forms permettant de g√©rer des groupes de contr√¥le et de valider les champs
        de formulaires
        Il est n√©cessaire d‚Äôimporter ReactiveFormsModule au niveau du module ou de l‚Äôapp
        Nous allons privil√©gi√© les Reactive Forms
        COGNITIC
        8.2 Le FormBuilder
        La classe int√©gr√©e √† Angular, FormBuilder, nous permet de d√©clarer facilement nos formulaires
        r√©actifs. Elle devra √™tre inject√© dans le constructeur. L‚Äôobjet ainsi instanci√© s‚Äôoccupera de g√©rer les
        ‚Äúcontr√¥le‚Äù de formulaire et d‚Äôy inclure des ‚ÄúValidator‚Äù
        71
        Sans oublier de l‚Äôimporter de @angular/forms
        L‚Äôobjet _formBuilder nous propose d√®s lors
        3 possibilit√©s : array, control et group
        COGNITIC
        8.3 formControl
        Le contr√¥le est l‚Äôunit√© de base du formulaire, il repr√©sente un input pr√©sent√© dans l‚Äôhtml
        72
        Le premier param√®tre de
        construction permet de d√©finir la
        valeur d‚Äôinitialisation contenue dans
        l‚Äôinput li√© √† notre contr√¥le.
        Le second repr√©sente le/les Validator(s)
        que nous voudrions appliquer au contr√¥le.
        => voir plus loin dans le chapitre
        Nous pr√©f√©rons laisser le soin au FormBuilder, de g√©rer la cr√©ation et l‚Äôinstance de notre
        contr√¥le. Le laissant jouer son r√¥le de chef d‚Äôorchestre pour les Reactive Forms
        COGNITIC
        8.3 formControl
        Une fois notre contr√¥le d√©fini c√¥t√© TS, nous devrons le li√© √† un Input de formulaire par
        l‚Äôattribut formControlName
        73
        Remarque : Nous utiliserons tr√®s rarement un contr√¥le seul. Nous pr√©f√©rons utiliser
        l‚Äôoption du Template-Driven Form le cas √©ch√©ant
        COGNITIC
        8.4 formGroup
        Un FormGroup regroupe plusieurs
        FormControl, voir un formulaire complet
        pour aider √† la validation globale de celui
        ci.
        74
        D√©clarons une propri√©t√© contenant le
        FormGroup
        Ensuite, nous initialisons le groupe en laissant le
        FormBuilder se charger de tout.
        La m√©thode .group() permet d‚Äôinstancier un tableau
        d‚Äôobjet de type FormControl tr√®s simplement
        COGNITIC
        8.4 formGroup
        75
        La mise en place c√¥t√© HTML d‚Äôun formGroup est tr√®s simple.
        - Lier le formGroup gr√¢ce √† la directive [formGroup] du Formulaire (ce qui a
        pour effet de remplacer l‚Äôattribut ‚Äúaction=page.xxx‚Äù de <form> et de lier
        facilement les formControl au diff√©rents √©l√©ments).
        - Lier ensuite chaque Input au formControl qui lui est d√©di√©
        COGNITIC
        8.5 formArray
        Permet de cr√©er un tableau de contr√¥le. Dans le cas ou on ignore le nombre de contr√¥les √† cr√©er
        ou si de nouveaux contr√¥le doivent √™tre ajout√© en cours de route
        76
        Une fois d√©clar√©, il est n√©cessaire de pouvoir y acc√©der :
        Le type FormArray repr√©sente une collection de
        FormControl. Et qui dit collection, dit push(), remove(), ‚Ä¶.
        COGNITIC
        8.5 formArray
        Notre FormArray, d√©sormais facilement accessible, peut √™tre manipuler comme n‚Äôimporte quelle collection
        77
        Ajout d‚Äôun contr√¥le :
        Affichage des contr√¥le :
        Remarque : Le nom de chaque contr√¥le correspond √† son index dans la collection
        COGNITIC
        8.6 Validators principaux
        Ils vont permettre de v√©rifier que les valeurs entr√©es correspondent √† ce qui est attendu.
        78
        Validators.min(X) Oblige une valeur num√©rique minimale X
        Validators.max(X) Limite √† une valeur maximale X
        Validators.required Force une valeur non vide
        Validators.email Impose de respecter le format E-mail ‚Äúx@x.x‚Äù
        Validators.minLength(X) Longueur minimale de X de la valeur (cha√Æne de caract√®re)
        Validators.maxLength(X) Longueur maximale de X de la valeur (cha√Æne de caract√®re)
        Validators.pattern(regex) Oblige √† correspondre √† une expression r√©guli√®re
        COGNITIC
        8.7 Validation de formulaire
        Gr√¢ce √† nos objets formGroup ou
        formContol, nous avons acc√®s √† une
        propri√©t√© valid qui retourne True/False
        en fonction des validations impos√©es
        par nos validators. Ce qui nous permet
        d‚Äôafficher ou non des messages d‚Äôerreur
        (*ngIf) ou de soumettre ou non le
        formulaire.
        79
        Afficher un message d‚Äôerreur
        Autoriser la validation du formulaire
        COGNITIC
        8.8 Soumission et r√©cup√©ration de donn√©es
        Une fois valid√©, nous soumettons le formulaires via un Event Binding
        (ngSubmit)=‚Äùmethod()‚Äù.
        Et nous r√©cup√©rons les donn√©es gr√¢ce √† la propri√©t√© ‚Äúvalue‚Äù du FormGroup.
        80
        COGNITIC
        8.9 Custom Validator
        Angular nous donne la possibilit√© de d√©finir nos propres Validators.
        81
        Il suffit de mettre en place une
        m√©thode qui retourne un objet de type
        ValidatorFn (fonction de validation)
        Il reste √† appeler cette fonction de
        validation dans la liste des Validators de
        notre champ
        Remarque : La best-practice nous sugg√®re d‚Äôexternaliser ces Custom Validators dans un but de r√©utilisabilit√©
        9 Routing
        82
        COGNITIC
        Table des mati√®res
        83
        Routing
        9.1 Routing Module
        9.2 Eager Vs Lazy Loading
        9.3 Router
        9.4 Activated Route
        9.5 Guard
        9.6 Resolver
        COGNITIC
        9.1 Routing module
        Rappel :
        Comme vu pr√©c√©demment, chaque module peut inclure son propre routing. Bien que
        non n√©cessaire, il est conseill√© d‚Äôadopter cette pratique pour chaque module
        regroupant plusieurs composants. (ex : Admin panel, DashBoard, User feature, ‚Ä¶)
        Nous prendrons donc le parti mettre en place des ‚Äúchildren‚Äù et nous retrouver avec un
        template de route similaire √† : ‚Äúmonsite.com/module/composant‚Äù.
        Dans le cas d‚Äôun module d‚Äôimport/export tel que le ‚ÄúSharedModule‚Äù mis en place.
        Aucun routing n‚Äôest n√©cessaire.
        84
        COGNITIC
        9.1 Routing module
        Les routes sont d√©finies dans le tableau d‚Äôobjet de type Routes. Pour qu‚Äôune route soit
        valide, l‚Äôobjet attend au minimum une propri√©t√© ‚Äúpath‚Äù qui d√©fini le chemin d‚Äôacc√®s. La
        suite des param√®tres d√©pend des besoins.
        Le d√©corateur @NgModule du routing est n√©cessaire pour importer RouterModule et en
        d√©finir la port√©e.
        - forRoot(routes) => il s‚Äôagit du routing principal de l‚Äôapplication
        - forChild(routes) => tout sous-module de routing d√©pendant de son parent
        85
        COGNITIC
        9.1 Routing module
        Dans la propri√©t√© ‚Äúpath‚Äù des routes, il est possible de d√©finir un chemin par d√©faut.
        path : ‚Äò**‚Äô => signifie que les chemins non d√©finis pr√©c√©demment seront prit en
        charge par cette route.
        Nous pouvons d√®s lors rediriger vers une autre route (redirectTo).
        path : ‚Äò‚Äô => repr√©sente le chemin vide, il est donc possible de rediriger vers l‚Äôendroit
        voulu en cas d‚Äôurl http://monsite.com/ . Autrement dit, nous choisissons le point d‚Äôentr√©e
        86
        COGNITIC
        9.2 Eager VS Lazy Loading
        Chaque module (except√© le root) peut √™tre d√©fini, au sein du routing principal, comme
        charger au d√©marrage de l‚Äôapplication (Eager-loaded) ou charger √† la demande
        (Lazy-loaded).
        Dans un soucis de performance, le lazy-loading est recommand√©. En effet, si un
        module est inutile lors d‚Äôun traitement ou de la navigation d‚Äôun utilisateur
        (ex : Adminpanel). Il n‚Äôest pas n√©cessaire de surcharger le serveur.
        En cas de lazy loading. Il est important de bien g√©rer l‚Äôinjection de d√©pendances et
        en particulier les providers de service. (Un service dont le provider n‚Äôest pas charg√©,
        n‚Äôexiste pas)
        87
        COGNITIC
        9.3 Router
        La classe Router permet de g√©rer les routes au sein d‚Äôun composant ou d‚Äôun service
        88
        Il est n√©cessaire d‚Äôinjecter la classe Router dans le constructeur
        du composant ou service qui l‚Äôutilisera
        Nous pouvons envoyer l‚Äôutilisateur vers la route voulue, avec la possibilit√©
        d‚Äôajouter des param√®tres et les traiter dans le routing module
        COGNITIC
        9.4 ActivatedRoute
        La classe ActivatedRoute repr√©sente la route active (ou qui vient d‚Äô√™tre emprunter lors
        de la navigation). Il est possible d‚Äôy r√©cup√©rer des param√®tres de route. Des objets
        charg√© par Resolver ou simplement la connaissance d‚Äôo√π on vient.
        89
        Gr√¢ce au tableau params se trouvant dans la propri√©t√©
        snapshot. Nous r√©cup√©rons facilement nos param√®tres de
        route.
        Remarque : la propri√©t√© snapshot repr√©sente la route √† l‚Äôinstant T
        COGNITIC
        9.5 Guard
        Il nous est possible de d√©finir si une route peut √™tre activ√©e ou pas. Peut-on acc√©der au
        composant/module voulu, ou pas ?
        - ng g guard nom_de_guard
        Impl√©menter CanActivate pour d√©finir si la route peut r√©pondre ou pas.
        - return True => route activ√©e
        - return False => route inaccessible
        activate : GuardName (dans les param√®tres d‚Äôune route pour activer la garde)
        90
        COGNITIC
        9.6 Resolver
        Le resolver permet de ‚Äúr√©soudre un objet‚Äù durant la navigation.
        Exemple :
        - Chargement d‚Äôun objet venant d‚Äôun service
        - R√©soudre un appel API
        Permet d‚Äô√©viter les erreurs d‚Äôobjet ‚Äúundefined‚Äù lors d‚Äôappel asynchrone d‚Äôobjet √† envoyer au
        template visuel
        On peut dire qu‚Äôil s‚Äôagit d‚Äôun ‚Äútime-stop‚Äù durant la navigation pour loader un objet avant d‚Äôarriver √†
        destination
        91
        COGNITIC
        9.6 Resolver
        92
        1. D√©clarer le service de r√©solution
        et son comportement
        2. D√©finir la propri√©t√© ‚Äúresolve‚Äù de la
        route pour y exposer le service de resolver
        et sp√©cifier un nom pour l‚Äôobjet r√©solu
        3. R√©cup√©rer l‚Äôobjet r√©solu gr√¢ce √†
        ActivatedRoute, dans le composant cible
        COGNITIC
        Exercice
        Mettre en place un CRUD de fan de s√©rie.
        Chaque fan sera d√©fini par son nom, sa date de naissance(interdit au moins de 13 ans), et la liste
        de leur s√©ries pr√©f√©r√©es (juste le titre).
        Aucune limitation du nombre de s√©ries d√©finie par l‚Äôutilisateur √† la cr√©ation de son profil
        Sur la page de modification de profil, il doit √™tre possible d‚Äôajouter ou supprimer des s√©ries.
        - 4 composants (liste des fans, d√©tails, cr√©ation, mise √† jour)
        - Seule l‚Äôann√©e est v√©rifi√©e pour l‚Äô√¢ge des fans
        - Si un champ est visible, il sera obligatoirement rempli
        93
        COGNITIC
        10 Storage
        94
        COGNITIC
        Table des mati√®res
        95
        Les storages
        10.1 LocalStorage vs SessionStorage
        10.2 M√©thodes associ√©es
        COGNITIC
        10.1 Diff√©rence entre les deux storages
        Le sessionStorage garde les infos voulues jusqu‚Äô√† ce que le navigateur ou l‚Äôonglet soit
        ferm√©
        Le localStorage quand √† lui est disponible jusqu‚Äô√† ce que l‚Äôapplication vide le storage ou
        que l‚Äôutilisateur vide le cache de son navigateur.
        Pour les deux : stockage jusqu‚Äô√† 10mo pour la plupart des navigateurs
        96
        COGNITIC
        10.2 M√©thodes associ√©es
        97
        Qu‚Äôil s‚Äôagisse du local ou du session storage, les commandes
        sont identiques. Seul le comportement global est diff√©rent
        Ajoute un valeur en session (de type string uniquement)
        R√©cup√®re la valeur stock√©e √† la cl√© ‚Äúkey‚Äù
        Supprime une cl√© et la valeur associ√©e de la session
        Vide compl√®tement la session (cl√©s et valeurs)
        COGNITIC
        11 Observable
        98
        COGNITIC
        Table des mati√®res
        99
        Les observable
        11.1 La librairie RXJS
        11.2 Subject / BehaviorSubject
        11.3 Subscribe()
        11.4 Subscription
        11.5 Op√©rateur RXJS
        COGNITIC
        11.1 La librairie RXJS
        Faisant partie du bundle de base
        d‚ÄôAngular, cette librairie contient tout le
        n√©cessaire pour g√©rer les Observable.
        Ceux-ci sont le fondement de la
        programmation dite r√©active et
        permettent en gros, de ne plus avoir √†
        charger manuellement une valeur si elle
        est observ√©e
        100
        Au del√† de √ßa, elle permet de g√©rer des
        comportements asynchrones (appel d‚Äôapi
        par exemple) et am√®ne des outils de gestion
        de collection observable
        Remarque : Ce chapitre ne couvre pas l‚Äôenti√®ret√© des possibilit√©s de
        RXJS mais apporte l‚Äôessentiel pour la compr√©hension des observable
        https://www.learnrxjs.io/
        COGNITIC
        11.2 Subject et BehaviorSubject
        101
        Pour que plusieurs composants puissent se
        baser sur le m√™me service et donc les m√™mes
        valeurs. Il sera n√©cessaire d‚Äôutiliser la notion
        d‚Äôobservable.
        Nous verrons dans le chapitre suivant que les
        appels api (HttpClient) retourne d‚Äôoffice un
        observable. Mais dans le cas de propri√©t√©s ou
        d‚Äôobjets g√©r√©s par l‚Äôapplication elle-m√™me, il
        faut mettre en place soi-m√™me cette notion.
        C‚Äôest l√† qu‚Äôinterviennent les Subject
        Autre avantage non n√©gligeables, nous acc√©dons √† la notion
        d‚Äôabstraction (plus d‚Äôacc√®s direct √† une propri√©t√©s) et pouvons d√®s lors
        utiliser l‚Äôencapsulation de mani√®re efficace.
        COGNITIC
        11.2 Subject et BehaviorSubject
        102
        Les types Subject et BehaviorSubject permettent de d‚Äô
        √©mettre la valeur d‚Äôune propri√©t√©s aux diff√©rents
        composant abonn√© √† ce subject.
        La diff√©rence fondamentale entre les deux types est
        que le BehaviorSubject √©met sa valeur par d√©faut lors
        de sa construction. Contrairement au Subject.
        Pour les deux, √† chaque nouvelle modification, il faudra
        √©mettre la valeur.
        Le BehaviorSubject √† √©galement la particularit√© de
        garder sa derni√®re valeur √©mise en m√©moire. Elle est
        accessible via la m√©thode GetValue()
        La m√©thode next de mySubject , qu‚Äôil soit Subject
        o√π BehaviorSubject, enverra la valeur de property √†
        tous les abonn√©s (voir slide suivant)
        COGNITIC
        11.3 Subscribe
        103
        Pour suivre l‚Äô√©volution d‚Äôun
        observable, il sera n√©cessaire de
        s‚Äôy abonner via la m√©thode
        subscribe() disponible pour
        n‚Äôimporte quel type observable
        La m√©thode subscribe() attend jusqu‚Äô√† trois lambas,
        1) le param√®tre d‚Äôentr√©e repr√©sente la valeur √©mise par
        l‚Äôobservable. Et dont l‚Äôexpression repr√©sente le traitement
        ex√©cut√© √† chaque nouvelle √©mission de l‚Äôobservable
        2) le param√®tre d‚Äôentr√©e repr√©sente l‚Äô√©ventuel erreur
        retourn√©e par l‚Äôobservable et l‚Äôexpression, le traitement √†
        faire en cas d‚Äôerreur.
        3) Repr√©sente l‚Äôaction √† effectuer qu‚Äôil y ai des erreurs ou pas
        Nous pouvons comparer √ßa √† un bloc ‚Äútry catch finally‚Äù
        COGNITIC
        11.4 Subscription
        104
        L‚Äôobjet Subscription permet de stocker le statut de
        la m√©thode subscribe() . Ce qui veut dire qu‚Äôil est
        possible d‚Äôagir sur cette souscription pour s‚Äôen
        d√©sabonner par exemple.
        COGNITIC
        11.5 Op√©rateurs RXJS
        105
        Nous sommes capable de nous abonn√©s √† des
        observables. Il temps d‚Äôapprendre √† s‚Äôen servir.
        Il est possible d‚Äôappliquer diff√©rents op√©rateurs √†
        l‚Äôobservable avant de d√©clarer la souscription.
        Au travers de la m√©thode .pipe()
        Ce cours ne couvre pas la liste des op√©rateurs.
        La liste exhaustive se trouve ici :
        https://www.learnrxjs.io/learn-rxjs/operators
        COGNITIC
        12 HttpClient
        106
        COGNITIC
        Table des mati√®res
        107
        HttpClient
        12.1 Discussion API <-> Angular
        12.2 HttpVerbs de base
        12.3 Interceptor
        COGNITIC
        12.1 Api <> Angular
        108
        La discussion entre API et Angular passe par la le module HttpClient ( => importer HttpClientModule)
        API
        - Database
        - Controller
        - Models
        - ‚Ä¶
        Angular
        - Services
        - Components
        - Models
        - HttpClient
        HttpRequest
        HttpResponse
        Header, HttpVerb,
        Content,...
        Header, Status code,
        ResponseMessage
        Remarque : Chaque action Http retourne un objet de type Observable<T>
        COGNITIC
        12.2 Http Verbs
        109
        Verbe Utilit√© Exemple Angular
        Get R√©cup√©ration de donn√©es
        Post Envoi de donn√©es (possibilit√©
        d‚Äôen recevoir en retour)
        Put Modification de donn√©es
        Delete Suppression de donn√©e
        Un param√®tre optionnel suppl√©mentaire permet de donner des
        infos de header (comme ‚ÄúAuthorization‚Äù, ‚ÄúContent-Type‚Äù, ‚Ä¶)
        Attention:
        S‚Äôil y a objet en
        httpResponse, il est
        n√©cessaire de typer
        la m√©thode en
        ajoutant le type
        entre chevron
        (ex : get<T>)
        COGNITIC
        12.3 Interceptor
        110
        L‚Äôobjet interceptor va, comme son nom l‚Äôindique,
        intercepter les requ√™tes Http et les retourner
        ‚Äúmodifi√©es‚Äù. Pour, par exemple y inclure des
        informations de Header.
        Le param√®tre req correspond √† la requ√™te intercept√©e, quant au
        param√®tre next, il fait r√©f√©rence √† la requ√™te une fois modifi√©e
        COGNITIC
        12.3 Interceptor (suite)
        111
        Il faudra ensuite pr√©ciser au niveau des providers du module la
        classe d‚Äôintercepteur √† utiliser.
        provide : pr√©cise ce qui doit √™tre g√©rer (ici l‚Äôinterception HTTP).
        useClass : l‚Äôinstance de classe √† utiliser
        multi : (true/false par d√©faut). D√©finit s‚Äôil est possible d‚Äôavoir
        plusieurs instances de la classe en m√™me temps
        COGNITIC
        13 Publication
        112
        COGNITIC
        13 Build de l‚Äôapplication
        113
        Il est tr√®s facile de build son application pour
        d√©ployer sur n‚Äôimporte quel serveur pouvant
        h√©berger de l‚Äôhtml.
        Il suffit de tapper la commande
        ng build
        Et d‚Äôy ajouter l‚Äôoption --prod pour minifier le code.
        Le build est alors d√©poser dans un r√©pertoire /dist.
        Copiez en le contenu sur votre h√©bergeur et le tour
        est jou√©.
        Attention : Si vous ne d√©posez pas le projet √† la
        racine de votre serveur, il faudra sp√©cifier le
        chemin d‚Äôacc√®s dans le fichier index.html √† la
        ligne en rempla√ßant le / par la route n√©cessaire
        COGNITIC
        Merci pour votre attention!</textarea
        >
      </li>
    </ul>

    <!--Liste de item ajout√©s-->
    <div>
      <ul>
        <p *ngFor="let item of myList"></p>
      </ul>
    </div>
  </form>
  <!--fichier.file-->
  <div style="margin: 40px">
    <button
      style="font-size: 10px; inline-size: 85px; block-size: 35px"
      (click)="downloadDataAsJson()"
    >
      üíæT√©l√©charger JSON
    </button>
  </div>
</div>
