<!--**********************************-->
<!--Ressources documents.pdf cours DEV-->
<!--**********************************-->
<button style="text-align: start" title="cylabus.pdf">
  ğŸ’¾&nbsp;Ressources .pdf (cylabus de cours DEV)
</button>
&nbsp;&nbsp;&nbsp;ğŸ“
<button
  style="
    display: inline;
    inline-size: 85px;
    block-size: 25px;
    color: white;
    background-color: red;
  "
  onclick="alert('ğŸš« pas autorisÃ©!')"
>
  Delete
</button>
&nbsp;
<button
  style="
    display: inline;
    inline-size: 85px;
    block-size: 25px;
    color: white;
    background-color: rgb(0, 17, 255);
  "
  onclick="alert('ğŸš« pas autorisÃ©!')"
>
  Update
</button>
<p style="color: blue; display: inline">Date: 13/12/2023</p>
<p style="color: rgb(0, 0, 0); display: inline">Ressource.pdf (Angular)</p>
&nbsp;
<a href="assets\pdf\Angular.pdf" style="display: inline">Angular</a>&nbsp;<img
  src="assets\logo\icone_PDF.jpg"
  width="2%"
/>
<!-- Add textarea for the PDF visualization --><textarea
  style="
    display: block;
    inline-size: 97%;
    block-size: 50px;
    margin: 10px;
    font-size: 16px;
  "
>
Angular
COGNITIC
Table des matiÃ¨res
1. Introduction
2. Projet Angular
3. Binding
4. Pipes
5. Directives
6. @Input / @Output
7. Services et Injection
8. Formulaires
9. Routing
10. Storage
11. Observable
12. HttpClient
13. Publication
2
COGNITIC
1. Introduction
3
COGNITIC
Table des matiÃ¨res
4
Introduction
1.1 Angular ? Câ€™est quoi ?
1.2 Avantages / InconvÃ©nients
1.3 NodeJS
1.4 Typescript
1.5 Installation
1.6 Outils
COGNITIC
1.1 Angular ? Câ€™est quoi ?

5
Angular est un framework de dÃ©veloppement front-end mis
en place par Google et basÃ© sur Javascript (au travers de
NodeJS et Typescript)
Il permet de mettre en place des SPA (Single Page
Application). Autrement dit : la navigation entre les â€œpagesâ€
semble invisible pour lâ€™utilisateur. Il a lâ€™impression de rester
constamment sur la mÃªme page puisquâ€™il nâ€™y a pas de
rechargement de lâ€™intÃ©gralitÃ© du site dâ€™une page Ã  lâ€™autre.
La premiÃ¨re version du framework date de 2016 et se met Ã 
jour rÃ©guliÃ¨rement pour rÃ©pondre aux attentes du monde
professionnel.
https://angular.io/
COGNITIC
1.2 Avantages / InconvÃ©nients
 Pour
- Framework complet pour le front
- Injection de dÃ©pendances
- Compilation rapide
- Documentation complÃ¨te et
simple
- Evolue constamment
- ModÃ¨le proche du MVVM
- Avantage du Typescript
6
 Contre
- Lourdeur de la syntaxe
- Pas dâ€™accÃ¨s direct Ã  une DB
- Migration dâ€™une version Ã  lâ€™autre
problÃ©matique (les librairies
mettent du temps Ã  suivre)
- Courbe dâ€™apprentissage Ã©norme
COGNITIC
1.3 NodeJS
7
En quelques mots : NodeJS est un environnement
back-end dÃ©veloppÃ© en Javascript sur base de la
machine virtuelle V8, moteur dâ€™exÃ©cution JS (qui se
cache dans Chrome).
Il permet de maniÃ¨re trÃ¨s lÃ©gÃ¨re, de mettre en place
des APIs (grÃ¢ce Ã  Express) et permet l'exÃ©cution du
Javascript cÃ´tÃ© serveur.
Il est associÃ© Ã  un gestionnaire de paquet - NPM -
qui fonctionne via un terminal et permet dâ€™ajouter
des dÃ©pendances tel que Angular, Ã  un projet. https://nodejs.org/en/
COGNITIC
1.4 Typescript
8
Il sâ€™agit dâ€™un langage dÃ©veloppÃ© par Microsoft pour
faciliter et â€œsÃ©curiserâ€ la production de code
Javascript.
Typescript est en rÃ©alitÃ© une surcouche du JS. Ce qui
signifie que tout code JS est un code Typescript
valide.
Il apporte les notions de programmation orientÃ©
objet et de typage statique des variables qui font
cruellement dÃ©faut Ã  Javascript pour en faire un
langage beaucoup plus structurÃ© et facile dâ€™accÃ¨s.
https://www.typescriptlang.org/
COGNITIC
1.5 Installation dâ€™Angular
1. Installer NodeJS (prendre la version LTS sur le site officiel)
2. Installer Angular en ligne de commande (WIN+R => CMD)
npm install -g @angular/cli
Le paramÃ¨tre -g permet une installation globale au niveau du systÃ¨me et pas
uniquement dans le dossier ou vous vous situez
3. VÃ©rifier que lâ€™installation est bien terminÃ©e en tapant
ng version
9
COGNITIC
1.6 Outils
Lâ€™Ã©diteur utilisÃ© dans le cadre du cours sera Visual Studio Code
https://code.visualstudio.com/
Il permettra dâ€™installer des plug-ins spÃ©cifiques Ã  Angular :
- Angular Schematics => exÃ©cution de commande via un menu contextuelle
- Angular Snippets
- Angular Language Service
Les deux suivants amÃ¨nent des aides au code comme lâ€™auto complÃ©tion ou des
raccourcis dâ€™Ã©criture.
10
COGNITIC
2. Projet Angular
11
Mise en place
COGNITIC
Table des matiÃ¨res
12
Projet Angular
2.1 CrÃ©ation du projet
2.2 Arborescence
2.3 Les Modules
2.4 CrÃ©ation de module
2.5 Les Composants
2.6 Cycle de vie des composants
2.7 Intro Ã  la navigation
COGNITIC
2.1 Commandes et options
- ng new â€œnom_du_projetâ€ => CrÃ©e un dossier â€œnom_du_projetâ€ en y copiant tout
ce qui est nÃ©cessaire au framework
 Options
13
--skip-tests DÃ©sactive la copie des fichiers de test unitaires
--routing Ajoute le routage Ã  lâ€™application
--strict (true/false) Utilisation du mode strict qui force lâ€™initialisation des
variables/propriÃ©tÃ© dans le constructeur
--skip-git DÃ©sactive lâ€™initialisation par dÃ©faut du dÃ©pÃ´t Git
Liste des options : https://angular.io/cli/new
COGNITIC
2.1b Installation du projet
Une fois la commande basique exÃ©cutÃ©e (ng new â€œprojetâ€), le systÃ¨me vous posera 2
questions
1. Ajouter angular routing ? => rÃ©pondre oui
2. Mode de template css ? => choisir SCSS (pour plus de compatibilitÃ© avec les
diffÃ©rents framework/librairie graphiques)
Ces questions peuvent Ãªtre Ã©vitÃ©es en ajoutant les options adÃ©quates Ã  la commande
de base.
14
COGNITIC
2.1c DÃ©marrer le serveur -- NG SERVE
La commande - ng serve - compile et dÃ©marre lâ€™application sur le port 4200 (par dÃ©faut).
Dans le cas oÃ¹ vous auriez plusieurs applications qui tournent en parallÃ¨le, il est
possible de modifier le port de lâ€™app
ng serve --port=42XX
Lâ€™option --open ouvre lâ€™app dans le navigateur par dÃ©faut une fois celle ci compilÃ©e
Une fois compilÃ©e et dÃ©marrÃ©e, lâ€™application pourra Ãªtre modifiÃ©e sans avoir Ã  relancer le
serveur. Le processus â€œAhead-of-timeâ€ se charge de recompilÃ© en direct lâ€™application Ã 
chaque sauvegarde de fichier.
15
COGNITIC
2.2 Arborescence du projet
Les diffÃ©rents dossiers et fichiers importants
16
Fichier/dossier UtilitÃ©
/e2e Dossier rÃ©servÃ© aux tests end user
/node_modules Contient tout les modules nÃ©cessaire au fonctionnement du framework, ainsi que les
module ajoutÃ© par la suite ( => ne pas toucher !!! )
/src Dossier principal de dÃ©veloppement. Câ€™est lÃ  quâ€™on va travailler
angular.json Configuration du workspace et du projet
package.json Liste et version des packages utilisÃ©s dans le projet
tsconfig.json Configuration de la compilation Typescript
tslint.json Configuration permettant la vÃ©rification du code Ã  chaud sans le compiler
COGNITIC
2.2 Arborescence du projet
DÃ©tails du dossier /src
17
Fichier/dossier UtilitÃ©
/app Câ€™est la que lâ€™application prend vie. On y intÃ©grera nos pages ainsi que leur logique
/assets Contiendra les Ã©ventuelles mÃ©dia supplÃ©mentaires (images, sons, vidÃ©os)
nÃ©cessaires Ã  lâ€™applications
/environments Permettra de localiser les variables dâ€™environnement tel que les adresses dâ€™ API
index.html Point dâ€™entrÃ©e de lâ€™application. Contiendra les imports css/js Ã©ventuelles
styles.scss Feuille de style par dÃ©faut de lâ€™application
main.ts Permet de dÃ©finir le module de dÃ©marrage le lâ€™app (laisser par dÃ©faut de prÃ©fÃ©rence)
COGNITIC
2.3 app module
La programmation Angular est dite â€œModulaireâ€ ce qui signifie que nous allons mettre en place plusieurs
modules et les faires communiquer entre eux. Nous verrons cela plus tard. Attardons nous sur le module
principale de notre application. Celui crÃ©Ã© par dÃ©faut lors de la crÃ©ation dâ€™un projet et qui sera le point
dâ€™entrÃ©e de notre app
18
Il sâ€™agit du root module (module parent) qui englobe toute lâ€™application.
Il propose son propre routage, il sâ€™agit Ã©galement du point dâ€™entrÃ©e vers
les diffÃ©rentes logiques, fonctionnelle et visuelle, de votre application
Pour des raisons pratiques, nous ferons lâ€™impasse sur tous les fichiers suffixÃ©s .spec.ts . Ces fichiers
Ã©tant rÃ©servÃ©s aux tests unitaires.
COGNITIC
2.3 app.module.ts
Le fichier app.module.ts reprÃ©sente la configuration du module principal et propose diffÃ©rentes parties
que nous allons dÃ©taillÃ©s ici
19
Le dÃ©corateur @NgModule signifie au systÃ¨me que le fichier est le point
dâ€™entrÃ©e du module et permet dâ€™apporter une structure Ã  celui ci
declarations : [] => Nous y dÃ©clarons le/les composants utilisÃ©(s) par le module
imports : [] => Contient les diffÃ©rents modules importÃ©s et utilisÃ©s par celui en cours
exports : [] => Permet dâ€™exporter tout ou partie des modules/composants utilisÃ© par
celui en cours
providers : [] => Contiendra des informations pour lâ€™injection de dÃ©pendances
bootstrap : [] => Le composant dâ€™amorÃ§age du module (si composant il y a)
export class AppModule { } => signifie simplement que le module est exportÃ© et
donc importable ailleurs dans lâ€™application
COGNITIC
2.4 Module => crÃ©ation
20
Un module contiendra dâ€™office un fichier â€œnom.module.tsâ€. Qui, Ã  lâ€™instar du app.module.ts contiendra le
dÃ©corateur @ngModule.
ng g m nom_du_module => crÃ©e un nouveau module
Aucune obligation nâ€™existe quand Ã  la prÃ©sence dâ€™un composant ou dâ€™un routing spÃ©cifique dans un
nouveau module (exception faite pour le AppModule)
Il est nÃ©anmoins possible de crÃ©er un composant Ã  inclure directement dans un module.
ng g c nom_du_composant -m nom_du_module
Ajouter lâ€™option --routing pour inclure â€œnom-routing.module.tsâ€ au module dÃ©s sa crÃ©ation
COGNITIC
2.5 Component
Notre module principale, en plus dâ€™intÃ©grer un routing (que nous dÃ©taillerons plus tard), et un fichier de
configuration (app.module.ts), intÃ¨gre un component composÃ© de 3 fichiers
- app.component.html => Template visuel
- app.component.scss => Feuille de style
- app.component.ts => Code behind en typescript
Un component est lâ€™unitÃ© de travail en Angular. Autrement dit, nos pages seront basÃ©es sur des
components. Chacun Ã©tant composÃ© de ces 3 fichiers (html/css/ts)
ng generate component â€œnom_du_composantâ€|| ng g c â€œnom_du_composantâ€
==> Commande de crÃ©ation dâ€™un nouveau composant
21
COGNITIC
2.5 Component => TS
Câ€™est ici que nous mettrons en place toute la logique des composants au travers du code Typescript.
Ce fichier est composÃ© dâ€™un dÃ©corateur @Component et dâ€™une classe complÃ¨te avec son constructeur et
ses imports.
22
Les imports reprÃ©sentent tout modÃ¨les, modules ou
services nÃ©cessaires au fonctionnement du composant.
Câ€™est dans la classe que nous intÃ©grerons la logique
fonctionnelle (propriÃ©tÃ©s, mÃ©thodes, constructeur, ...)
COGNITIC
2.5 Component => TS
23
Le dÃ©corateur dÃ©crit 3 propriÃ©tÃ©s du composant
- selector => Permet dâ€™intÃ©grer ce
composant dans nâ€™importe quelle page
html
- templateUrl => Url de la page html liÃ©e au
composant
- styleUrls => Url de la feuille de style du
composant
Exemple dâ€™appel par sÃ©lecteur
Fichier TS
Fichier HTML
COGNITIC
2.5 Component => HTML
Le fichier.html dâ€™un component contiendra comme son extension lâ€™indique, du code
HTML principalement. Mais aussi divers choses qui nous viennent du framework
Angular :
- Directives
- Bindings
- Pipes
Qui seront bien Ã©videment vues en dÃ©tails dans les chapitres dÃ©diÃ©s
24
COGNITIC
2.6 Intro aux cycles de vie des composants
Le cycles de vie dâ€™un composant (Hooks) reprÃ©sente les diffÃ©rents instants de son existence. Chacun
dâ€™eux, demande que la classe du composant implÃ©mente lâ€™interface nÃ©cessaire Ã  son fonctionnement
OnInit => ExÃ©cute le contenu de la mÃ©thode ngOnInit() Ã  lâ€™initialisation du composant
 Ne s'exÃ©cute quâ€™une seule fois au premier appel du composant
25
COGNITIC
2.6 Intro aux cycles de vie des composants (suite)
OnDestroy => ExÃ©cute le contenu de la mÃ©thode ngOnDestroy() Ã  la destruction du composant
 Permet de libÃ©rer la mÃ©moire Ã  la destruction du composant (dÃ©sinscription aux
 Observables, fermeture de connexion Ã©ventuelle, â€¦)
26
COGNITIC
2.6 Intro aux cycles de vie des composants (fin)
Les deux hooks prÃ©sentÃ©s prÃ©cÃ©demment sont les plus frÃ©quemment utilisÃ©s. OnInit
est dâ€™ailleurs implÃ©mentÃ© de base Ã  la crÃ©ation dâ€™un nouveau composant.
Il en existe bien dâ€™autres qui peuvent Ãªtre utiles Ã  diffÃ©rents moments du
dÃ©veloppement. Ils sont dÃ©taillÃ©s dans la doc officielle dâ€™Angular
https://angular.io/guide/lifecycle-hooks
27
COGNITIC
2.7 Les bases de la navigation
Il est nÃ©cessaire de spÃ©cifier les routes dâ€™accÃ¨s Ã  nos composants pour pouvoir naviguer de maniÃ¨re fluide. Nous
utilisons les â€œrouting-moduleâ€ pour se faire.
28
app-routing.module.ts HTML
Lâ€™utilisation de lâ€™attribut â€œHREFâ€ implique un rechargement complet du site visible Ã  lâ€™oeil nu, ce qui va Ã  lâ€™encontre du principe de
Single Page App.
Lâ€™attribut â€œROUTERLINKâ€ offre un chargement invisible. En rÃ©alitÃ©, seul le composant appelÃ© par le routing est chargÃ© Ã  lâ€™endroit
ou se trouve la balise <router-outlet></router-outlet> dans le template HTML
COGNITIC
2.7 Les bases de la navigation
29
GrÃ¢ce Ã  la propriÃ©tÃ© â€œchildrenâ€, il est possible de dÃ©finir des
liens enfants, qui pourrait correspondre Ã  une architecture
Dossier/Sous-dossier.
Pour rendre ceci fonctionnel, il ne faudra pas oublier
dâ€™ajouter <router-outlet></router-outlet> au niveau du
composant parent (HomeCompenent)
Lâ€™exemple prÃ©cÃ©dent donne lieu Ã  lâ€™url :
http://localhost:4200/home/demo
COGNITIC
2.7 Les bases de la navigation
Dans le cas dâ€™une navigation inter-module, il
sera nÃ©cessaire dâ€™importer le routing des
modules secondaires au niveau du module
principal de lâ€™application pour que celui ci ait
accÃ¨s aux routes dÃ©clarÃ©es dans les autres.
30
Il faut Ã©galement dÃ©clarer le lien vers le
nouveau module dans le routing du
AppModule.
Nous utilisons cette mÃ©thode pour crÃ©er un
Lazy Loading entre les modules. Ce qui veut
dire que les sous modules et leur
composants ne seront chargÃ©s quâ€™Ã  la
demande et pas directement au lancement
de lâ€™application.
Nous choisissons le Lazy-Loading Vs le Eager-Loading
pour des questions de performances
COGNITIC
Exercice
Mettre en place 2 nouveaux modules (Demo et Exercice). Comprenant chacun un composant
dâ€™amorÃ§age et un routing spÃ©cifique.
CrÃ©er un composant de navigation et lâ€™inclure au template de base (menu Ã  droite de la page)
Tous les composants et modules doivent Ãªtre accessible Ã  partir de la page d'accueil de
lâ€™application
31
COGNITIC
3. Bindings
32
COGNITIC
Table des matiÃ¨res
33
Bindings
3.1 Property Binding
3.2 Event Binding
3.3 Attribute Binding
COGNITIC
3.1 Property bindings
Le property-binding crÃ©e une liaison entre une propriÃ©tÃ© Typescript et le template HTML. Il sâ€™agit
de faire interagir les 2 fichiers de maniÃ¨res Ã  apporter un certain dynamisme Ã  nos pages.
Il existe 2 types de property-binding :
- One-way => lecture du contenu dâ€™une propriÃ©tÃ© dans le template visuel
- Two-way => liaison montante et descendante dâ€™une propriÃ©tÃ©
(Les propriÃ©tÃ©s dÃ©clarÃ©e dans le fichier .TS sont par dÃ©faut public. Il est possible de changer cette accessibilitÃ©,
mais une propriÃ©tÃ© â€œprivateâ€ ne pourra pas Ãªtre accessible dans la page HTML)
34
COGNITIC
3.1 Property bindings : exemple
35
Typescript Html
One Way
Two Way
Si la valeur de maVariable est modifiÃ©e de
quelque maniÃ¨re que ce soit (ts ou html),
la mise Ã  jour se fait en temps rÃ©el des deux
cÃ´tÃ©s sans rafraichir la page.
Il est nÃ©cessaire dâ€™importer FormsModule
au niveau du module pour que [(ngModel)]
soit disponible
COGNITIC
3.2 Event Binding
Lâ€™event binding permet de lier un Ã©vÃ©nement JS (ex : onClick, onChange, onFocus,....) du template
HTML Ã  une mÃ©thode dÃ©finie dans le typescript.
36
Il est Ã©videmment possible de passer des paramÃ¨tres Ã  notre mÃ©thode
COGNITIC
3.3 Attribute Binding
Il est possible de conditionner lâ€™apparition dâ€™un attribut grÃ¢ce Ã  une expression
boolÃ©enne dans lâ€™html.
37
Il est Ã©galement possible de lier lâ€™attribut Ã  une propriÃ©tÃ©
TS HTML
COGNITIC
4. Pipes
38
COGNITIC
Table des matiÃ¨res
39
Les Pipes
4.1 Les pipes. Comment Ã§a marche ?
4.2 Les principaux pipes
4.3 Custom Pipe
COGNITIC
4.1 Les pipes - Comment Ã§a marche ?
40
Les pipes permettent de formater ou transformer lâ€™affichage dâ€™une propriÃ©tÃ© dans un binding.
Le nom â€œpipeâ€ vient du caractÃ¨re utilisÃ© pour y faire appel
SALUT LES GARS !
TypeScript
HTML
Navigateur
COGNITIC
4.2 Les principaux pipes
41
Pipe UtilitÃ©
| date(â€˜formatâ€™) Formate lâ€™affichage de la date
| uppercase Transforme la chaÃ®ne en majuscule
| lowercase Transforme la chaÃ®ne en minuscule
| titlecase Le premier caractÃ¨re de chaque mot en majuscule
| currency Prend une devise en paramÃ¨tre (EUR/USD/â€¦)
| json Convertit la valeur en chaÃ®ne Json (utile pour le dÃ©buggage)
Il sâ€™agit des principaux pipes utilisÃ©s : Liste complÃ¨te sur la doc officielle
COGNITIC
4.3 Les custom pipes
Il est possible de crÃ©er des pipes custom permettant de rÃ©pondre Ã  nos attentes prÃ©cises comme
des conversion de valeur, format dâ€™affichage spÃ©cifique ou tout autre besoin rencontrÃ©.
ng g pipe nom_du_pipe
42
Le dÃ©corateur @Pipe permet de
dÃ©finir le nom dâ€™appel du pipe
La classe ainsi crÃ©Ã©e implÃ©mente lâ€™interface PipeTransform
COGNITIC
4.3 Les custom pipes
Il est possible de dÃ©finir nos propres paramÃ¨tres pour notre pipes. Il demande de dÃ©finir la
mÃ©thode transform()
43
Le premier paramÃ¨tre(value : unknown)
reprÃ©sente la propriÃ©tÃ© sur laquelle le pipe
va Ãªtre appliquÃ©. Il est bien entendu que
les types doivent correspondre.
Le second (...args: unknown[]), tous les
paramÃ¨tres supplÃ©mentaires Ã©ventuels qui
pourraient accompagner le pipe
En dernier lieu, il sera nÃ©cessaire de
dÃ©finir le type de retour de notre pipe
1 2
3
COGNITIC
4.3 Les custom pipes (ProblÃ¨me)
44
ng g m Shared
Nous rencontrons dÃ¨s lors un problÃ¨me
dâ€™import au niveau de nos diffÃ©rents
modules.
Le systÃ¨me vous signifie que votre pipe
nâ€™est pas inclu/trouvÃ© par le module Demo.
Il faut recourir au subterfuge du
â€œSharedModuleâ€.
Autrement dit : un module qui servira de
passerelle pour vos diffÃ©rents pipes, directives,
services ou composants communs et partagÃ©s
entre diffÃ©rents modules. Ce module devra Ãªtre
importÃ© dans chaque module ou vos Ã©lÃ©ments
communs doivent se retrouver
SharedModule DemoModule
COGNITIC
Exercice
Mettre en place un chronomÃ¨tre
- 3 Boutons : Start, Pause, Reset (actif/inactif en fonction des besoins)
- Affichage â€œxx minutes xx secondesâ€
Astuce : cherchez du cÃ´tÃ© de setInterval() et du string Interpolation de Typescript ;)
45
COGNITIC
5 Les directives
46
COGNITIC
Table des matiÃ¨res
47
Les directives
5.1 Câ€™est quoi une directive ?
5.2 Components Directives
5.3 Structural Directives
5.4 Custom Directive
COGNITIC
5.1 Câ€™est quoi une directive ?
48
Il en existe diffÃ©rents types, et la possibilitÃ© dâ€™en crÃ©er sois-mÃªme.
- Directive de composants (NgClass, NgStyle, NgModel)
- Directive Structurelle (NgIf, NgFor, NgSwitch)
- Directive dâ€™attributs (custom directive)
Les directives sont des classes qui ajoutent un
comportement supplÃ©mentaire aux Ã©lÃ©ments de
vos applications Angular. Avec les Built-in
directives d'Angular, vous pouvez gÃ©rer les listes,
les styles et ce que voient les utilisateurs.
Elles sâ€™appliquent sur des composants/balises html
pour en conditionner lâ€™affichage
COGNITIC
5.2 Component Directives
Elles permettent de â€œtoucherâ€ Ã  lâ€™affichage de votre page.
- NgStyle (permet dâ€™ajouter du code CSS inline Ã  vos balises)
- NgClass (ajoute une classe CSS en fonction dâ€™une expression boolÃ©enne)
- NgModel (Comme dÃ©jÃ  vu, permet le binding two-way dâ€™une propriÃ©tÃ©)
49
COGNITIC
5.3 Structural directives
Permettent dâ€™intÃ©grer des structures conditionnelle dans votre template visuel.
- NgIf (Conditionne lâ€™affichage de contenu sur base dâ€™une expression boolÃ©enne)
- NgFor (Permet de rÃ©pÃ©ter un affichage n fois. Sert principalement Ã  parcourir des
collections)
- NgSwitch (Permet des structure conditionnelle type Switch/case comme son nom
lâ€™indique)
50
COGNITIC
5.4 Custom Directives
La crÃ©ation de custom directive se fait via la commande :
ng g directive nom_de_la_directive
51
Il est nÃ©cessaire, comme pour les
pipes, de dÃ©clarer la directive dans
le module qui lâ€™utilisera
COGNITIC
5.4 Custom Directives
52
Le dÃ©corateur @HostListener â€œÃ©couteâ€ ce
quâ€™il se passe et rÃ©agit en fonction de lâ€™
Ã©vÃ¨nement prÃ©cisÃ© entre ( )
Lâ€™utilisation par injection de ElementRef permet
dâ€™accÃ©der Ã  lâ€™Ã©lÃ©ment â€œelâ€ appelant la directive
COGNITIC
Exercice
Sur base dâ€™un modÃ¨le Link, mettre en place un menu de navigation rÃ©actif en fonction
dâ€™une liste de lien dÃ©finie dans le TS de nav-component
- Chaque module sera reprÃ©sentÃ© dans le menu (Demo, Exercices) et sera lâ€™occasion
dâ€™un sous-menu affichÃ©e/cachÃ©e sur un click
6. @Input @Output
54
Discussion entre composants
COGNITIC
Table des matiÃ¨res
55
@Input @Output
6.1 Faire discuter les composant
6.2 @Input
6.3 @Output
COGNITIC
6.1 Faire discuter les composants
Nous avons prÃ©cÃ©demment vu quâ€™il est possible dâ€™intÃ©grer un composant Ã  un
autre grÃ¢ce Ã  lâ€™appel par sÃ©lecteur.
Il nous est, par consÃ©quent, possible de crÃ©er un dialogue entre le composant
appelant (parent) et le composant appelÃ© (enfant) en nous servant
principalement du sÃ©lecteur et des dÃ©corateurs @Input et @Output
Dâ€™envoyer des informations du parent Ã  lâ€™enfant au travers de propriÃ©tÃ©s.
 Et de faire rÃ©agir le parent en fonction de ce quâ€™il se passe dans lâ€™enfant via des
EventEmitter
56
COGNITIC
6.2 @Input
GrÃ¢ce au dÃ©corateur @Input , lâ€™enfant est en mesure de recevoir une information
transmise par son parent.
57
Appel par sÃ©lecteur du cÃ´tÃ© parent en dÃ©finissant
une propriÃ©tÃ© Ã  transmettre Ã  lâ€™enfant
RÃ©cupÃ©ration et utilisation de la propriÃ©tÃ© dans le
composant enfant
TS
HTML
Le dÃ©corateur @Input doit Ãªtre importer de @angular/core
COGNITIC
6.3 @Output
Le dÃ©corateur @Output permet de dÃ©finir une rÃ©ponse de lâ€™enfant vers le parent au
travers dâ€™un EventEmitter que nous mettrons en place.
58
Mise en place de lâ€™EventEmitter cÃ´tÃ© enfant. Son
nom fera office de â€œtype dâ€™Ã©vÃ¨nementâ€ utilisable
du cÃ´tÃ© parent
Event Binding cÃ´tÃ© parent pour rÃ©cupÃ©rer la
rÃ©ponse de lâ€™enfant au travers de lâ€™Event mis en
place dans ce dernier
Le dÃ©corateur @Output et EventEmitter doivent Ãªtre importer de @angular/core
COGNITIC
6.4 NgContent
Du contenu peut Ãªtre dÃ©fini dans le parent pour lâ€™enfant. Et afficher dans lâ€™enfant via le
sÃ©lecteur <ng-content></ng-content>
59
COGNITIC
Exercice
Mettre en place une shopping list en deux composant.
Dans le premier, un champ texte permettant lâ€™ajout dâ€™un article Ã  la liste
Dans le deuxiÃ¨me, lâ€™affichage de la liste et la possibilitÃ© de supprimer un article.
Les deux composant doivent Ãªtre afficher sur la mÃªme page
60
COGNITIC
7 Service et Injection
61
COGNITIC
Table des matiÃ¨res
62
Les services
7.1 Pourquoi et comment ?
7.2 Injection de dÃ©pendances
COGNITIC
7.1 Les services pourquoi et comment
63
Les services permettent de regrouper des fonctionnalitÃ©s liÃ©es entre elles (comme la
consommation dâ€™un end-point dâ€™API) pour une meilleure maintenabilitÃ©.
Ou encore des fonctionnalitÃ©s partagÃ©es par toute lâ€™application (ex : la gestion des rÃ´les utilisateur
ou des mÃ©thodes de calcul) => Grand potentiel de rÃ©utilisabilitÃ©
Ils peuvent Ã©galement fournir Ã  un module ou un composant les outils nÃ©cessaires Ã  leur
fonctionnement
En bref, ils constituent le coeur de la logique fonctionnelle de lâ€™application.
Et atout non nÃ©gligeables, ils bÃ©nÃ©ficient de lâ€™injection de dÃ©pendances native en Angular.
COGNITIC
7.1 Les services pourquoi et comment
CrÃ©er un service : ng g s dossier/nom_du_service
64
Le dÃ©corateur @Injectable signifie que la classe est
injectable en tant que service.
Le paramÃ¨tres ProvidedIn est spÃ©cifique Ã  lâ€™injection
de dÃ©pendances.
COGNITIC
7.2 Injection de dÃ©pendances
Il sâ€™agit dâ€™un design pattern laissant
lâ€™application dÃ©cidÃ© de la nouvelle
instanciation dâ€™une classe de service ou de
lâ€™utilisation de lâ€™instance existante.
Le framework Angular embarque lâ€™injection
de dÃ©pendance de maniÃ¨re native. Et nous
permet de dÃ©finir la portÃ©e de nos
instances (module, composant,
application). Il nous faudra dÃ¨s lors dÃ©finir
deux choses : Le provider du service et ou
injecter ce dernier.
65
Du provider dÃ©pend la portÃ©e et la durÃ©e de vie
de lâ€™instance du service. Une fois dÃ©fini (voir
slide suivant), nous utiliserons lâ€™injection par
constructeur pour injecter notre service
COGNITIC
7.2 Injection de dÃ©pendances
66
Provider PortÃ©e et durÃ©e de vie Mise en place
Component Lâ€™instance nâ€™est disponible que durant la vie du composant.
(voir Cycle de vie) Et uniquement dans le composant (et ses
enfants) Une nouvelle instance du service sera instanciÃ©e Ã 
chaque appel de constructeur du composant
A dÃ©finir dans le tableau providers de
@Component
Module
eager-loaded
(Singleton)
Disponible pour toute lâ€™application dÃ¨s son lancement Le paramÃ¨tre providedIn de @Injectable dÃ©finit le
provider du service â€˜rootâ€™ ou â€˜nom_du_moduleâ€™
Ou dans le tableau providers de @NgModule
Module
lazy-loaded
(Singleton)
Disponible Ã  partir du moment ou le module est chargÃ©. Peut
causer des erreurs sâ€™il est injectÃ© avant que le module ne soit
chargÃ©
Root Module
(Singleton)
Disponible pour toute lâ€™application dÃ¨s son lancement
COGNITIC
Exercice
Optimiser la liste de course avec lâ€™utilisation dâ€™un service qui gÃ¨re la liste et les
mÃ©thodes qui peuvent sâ€™y appliquer
Ajouter la possibilitÃ© de gÃ©rer le nombre dâ€™articles voulu (Ex : Lait x 6, Tomates x 3, â€¦)
67
COGNITIC
8 Formulaires
68
COGNITIC
Table des matiÃ¨res
69
Les formulaires
8.1 Les diffÃ©rents formulaires
8.2 FormBuilder
8.3 FormControl
8.4 FormGroup
8.5 FormArray
8.6 Validators
8.7 Validation de formulaire
8.8 RÃ©cupÃ©ration des donnÃ©es
8.9 Custom Validator
COGNITIC
8.1 Les diffÃ©rents formulaires
70
La plupart des interactions utilisateur se font au travers de formulaires. Nous avons deux
options Ã  notre portÃ©e.
- Template-driven Forms => Input liÃ© Ã  une propriÃ©tÃ© par Two-way binding.
Rappel : Il faut importer FormsModule au niveau du module ou de lâ€™app
- Reactive Forms permettant de gÃ©rer des groupes de contrÃ´le et de valider les champs
de formulaires
Il est nÃ©cessaire dâ€™importer ReactiveFormsModule au niveau du module ou de lâ€™app
Nous allons privilÃ©giÃ© les Reactive Forms
COGNITIC
8.2 Le FormBuilder
La classe intÃ©grÃ©e Ã  Angular, FormBuilder, nous permet de dÃ©clarer facilement nos formulaires
rÃ©actifs. Elle devra Ãªtre injectÃ© dans le constructeur. Lâ€™objet ainsi instanciÃ© sâ€™occupera de gÃ©rer les
â€œcontrÃ´leâ€ de formulaire et dâ€™y inclure des â€œValidatorâ€
71
Sans oublier de lâ€™importer de @angular/forms
Lâ€™objet _formBuilder nous propose dÃ¨s lors
3 possibilitÃ©s : array, control et group
COGNITIC
8.3 formControl
Le contrÃ´le est lâ€™unitÃ© de base du formulaire, il reprÃ©sente un input prÃ©sentÃ© dans lâ€™html
72
Le premier paramÃ¨tre de
construction permet de dÃ©finir la
valeur dâ€™initialisation contenue dans
lâ€™input liÃ© Ã  notre contrÃ´le.
Le second reprÃ©sente le/les Validator(s)
que nous voudrions appliquer au contrÃ´le.
=> voir plus loin dans le chapitre
Nous prÃ©fÃ©rons laisser le soin au FormBuilder, de gÃ©rer la crÃ©ation et lâ€™instance de notre
contrÃ´le. Le laissant jouer son rÃ´le de chef dâ€™orchestre pour les Reactive Forms
COGNITIC
8.3 formControl
Une fois notre contrÃ´le dÃ©fini cÃ´tÃ© TS, nous devrons le liÃ© Ã  un Input de formulaire par
lâ€™attribut formControlName
73
Remarque : Nous utiliserons trÃ¨s rarement un contrÃ´le seul. Nous prÃ©fÃ©rons utiliser
lâ€™option du Template-Driven Form le cas Ã©chÃ©ant
COGNITIC
8.4 formGroup
Un FormGroup regroupe plusieurs
FormControl, voir un formulaire complet
pour aider Ã  la validation globale de celui
ci.
74
DÃ©clarons une propriÃ©tÃ© contenant le
FormGroup
Ensuite, nous initialisons le groupe en laissant le
FormBuilder se charger de tout.
La mÃ©thode .group() permet dâ€™instancier un tableau
dâ€™objet de type FormControl trÃ¨s simplement
COGNITIC
8.4 formGroup
75
La mise en place cÃ´tÃ© HTML dâ€™un formGroup est trÃ¨s simple.
- Lier le formGroup grÃ¢ce Ã  la directive [formGroup] du Formulaire (ce qui a
pour effet de remplacer lâ€™attribut â€œaction=page.xxxâ€ de <form> et de lier
facilement les formControl au diffÃ©rents Ã©lÃ©ments).
- Lier ensuite chaque Input au formControl qui lui est dÃ©diÃ©
COGNITIC
8.5 formArray
Permet de crÃ©er un tableau de contrÃ´le. Dans le cas ou on ignore le nombre de contrÃ´les Ã  crÃ©er
ou si de nouveaux contrÃ´le doivent Ãªtre ajoutÃ© en cours de route
76
Une fois dÃ©clarÃ©, il est nÃ©cessaire de pouvoir y accÃ©der :
Le type FormArray reprÃ©sente une collection de
FormControl. Et qui dit collection, dit push(), remove(), â€¦.
COGNITIC
8.5 formArray
Notre FormArray, dÃ©sormais facilement accessible, peut Ãªtre manipuler comme nâ€™importe quelle collection
77
Ajout dâ€™un contrÃ´le :
Affichage des contrÃ´le :
Remarque : Le nom de chaque contrÃ´le correspond Ã  son index dans la collection
COGNITIC
8.6 Validators principaux
Ils vont permettre de vÃ©rifier que les valeurs entrÃ©es correspondent Ã  ce qui est attendu.
78
Validators.min(X) Oblige une valeur numÃ©rique minimale X
Validators.max(X) Limite Ã  une valeur maximale X
Validators.required Force une valeur non vide
Validators.email Impose de respecter le format E-mail â€œx@x.xâ€
Validators.minLength(X) Longueur minimale de X de la valeur (chaÃ®ne de caractÃ¨re)
Validators.maxLength(X) Longueur maximale de X de la valeur (chaÃ®ne de caractÃ¨re)
Validators.pattern(regex) Oblige Ã  correspondre Ã  une expression rÃ©guliÃ¨re
COGNITIC
8.7 Validation de formulaire
GrÃ¢ce Ã  nos objets formGroup ou
formContol, nous avons accÃ¨s Ã  une
propriÃ©tÃ© valid qui retourne True/False
en fonction des validations imposÃ©es
par nos validators. Ce qui nous permet
dâ€™afficher ou non des messages dâ€™erreur
(*ngIf) ou de soumettre ou non le
formulaire.
79
Afficher un message dâ€™erreur
Autoriser la validation du formulaire
COGNITIC
8.8 Soumission et rÃ©cupÃ©ration de donnÃ©es
Une fois validÃ©, nous soumettons le formulaires via un Event Binding
(ngSubmit)=â€method()â€.
Et nous rÃ©cupÃ©rons les donnÃ©es grÃ¢ce Ã  la propriÃ©tÃ© â€œvalueâ€ du FormGroup.
80
COGNITIC
8.9 Custom Validator
Angular nous donne la possibilitÃ© de dÃ©finir nos propres Validators.
81
Il suffit de mettre en place une
mÃ©thode qui retourne un objet de type
ValidatorFn (fonction de validation)
Il reste Ã  appeler cette fonction de
validation dans la liste des Validators de
notre champ
Remarque : La best-practice nous suggÃ¨re dâ€™externaliser ces Custom Validators dans un but de rÃ©utilisabilitÃ©
9 Routing
82
COGNITIC
Table des matiÃ¨res
83
Routing
9.1 Routing Module
9.2 Eager Vs Lazy Loading
9.3 Router
9.4 Activated Route
9.5 Guard
9.6 Resolver
COGNITIC
9.1 Routing module
Rappel :
Comme vu prÃ©cÃ©demment, chaque module peut inclure son propre routing. Bien que
non nÃ©cessaire, il est conseillÃ© dâ€™adopter cette pratique pour chaque module
regroupant plusieurs composants. (ex : Admin panel, DashBoard, User feature, â€¦)
Nous prendrons donc le parti mettre en place des â€œchildrenâ€ et nous retrouver avec un
template de route similaire Ã  : â€œmonsite.com/module/composantâ€.
Dans le cas dâ€™un module dâ€™import/export tel que le â€œSharedModuleâ€ mis en place.
Aucun routing nâ€™est nÃ©cessaire.
84
COGNITIC
9.1 Routing module
Les routes sont dÃ©finies dans le tableau dâ€™objet de type Routes. Pour quâ€™une route soit
valide, lâ€™objet attend au minimum une propriÃ©tÃ© â€œpathâ€ qui dÃ©fini le chemin dâ€™accÃ¨s. La
suite des paramÃ¨tres dÃ©pend des besoins.
Le dÃ©corateur @NgModule du routing est nÃ©cessaire pour importer RouterModule et en
dÃ©finir la portÃ©e.
- forRoot(routes) => il sâ€™agit du routing principal de lâ€™application
- forChild(routes) => tout sous-module de routing dÃ©pendant de son parent
85
COGNITIC
9.1 Routing module
Dans la propriÃ©tÃ© â€œpathâ€ des routes, il est possible de dÃ©finir un chemin par dÃ©faut.
path : â€˜**â€™ => signifie que les chemins non dÃ©finis prÃ©cÃ©demment seront prit en
charge par cette route.
Nous pouvons dÃ¨s lors rediriger vers une autre route (redirectTo).
path : â€˜â€™ => reprÃ©sente le chemin vide, il est donc possible de rediriger vers lâ€™endroit
voulu en cas dâ€™url http://monsite.com/ . Autrement dit, nous choisissons le point dâ€™entrÃ©e
86
COGNITIC
9.2 Eager VS Lazy Loading
Chaque module (exceptÃ© le root) peut Ãªtre dÃ©fini, au sein du routing principal, comme
charger au dÃ©marrage de lâ€™application (Eager-loaded) ou charger Ã  la demande
(Lazy-loaded).
Dans un soucis de performance, le lazy-loading est recommandÃ©. En effet, si un
module est inutile lors dâ€™un traitement ou de la navigation dâ€™un utilisateur
(ex : Adminpanel). Il nâ€™est pas nÃ©cessaire de surcharger le serveur.
En cas de lazy loading. Il est important de bien gÃ©rer lâ€™injection de dÃ©pendances et
en particulier les providers de service. (Un service dont le provider nâ€™est pas chargÃ©,
nâ€™existe pas)
87
COGNITIC
9.3 Router
La classe Router permet de gÃ©rer les routes au sein dâ€™un composant ou dâ€™un service
88
Il est nÃ©cessaire dâ€™injecter la classe Router dans le constructeur
du composant ou service qui lâ€™utilisera
Nous pouvons envoyer lâ€™utilisateur vers la route voulue, avec la possibilitÃ©
dâ€™ajouter des paramÃ¨tres et les traiter dans le routing module
COGNITIC
9.4 ActivatedRoute
La classe ActivatedRoute reprÃ©sente la route active (ou qui vient dâ€™Ãªtre emprunter lors
de la navigation). Il est possible dâ€™y rÃ©cupÃ©rer des paramÃ¨tres de route. Des objets
chargÃ© par Resolver ou simplement la connaissance dâ€™oÃ¹ on vient.
89
GrÃ¢ce au tableau params se trouvant dans la propriÃ©tÃ©
snapshot. Nous rÃ©cupÃ©rons facilement nos paramÃ¨tres de
route.
Remarque : la propriÃ©tÃ© snapshot reprÃ©sente la route Ã  lâ€™instant T
COGNITIC
9.5 Guard
Il nous est possible de dÃ©finir si une route peut Ãªtre activÃ©e ou pas. Peut-on accÃ©der au
composant/module voulu, ou pas ?
- ng g guard nom_de_guard
ImplÃ©menter CanActivate pour dÃ©finir si la route peut rÃ©pondre ou pas.
- return True => route activÃ©e
- return False => route inaccessible
activate : GuardName (dans les paramÃ¨tres dâ€™une route pour activer la garde)
90
COGNITIC
9.6 Resolver
Le resolver permet de â€œrÃ©soudre un objetâ€ durant la navigation.
Exemple :
- Chargement dâ€™un objet venant dâ€™un service
- RÃ©soudre un appel API
Permet dâ€™Ã©viter les erreurs dâ€™objet â€œundefinedâ€ lors dâ€™appel asynchrone dâ€™objet Ã  envoyer au
template visuel
On peut dire quâ€™il sâ€™agit dâ€™un â€œtime-stopâ€ durant la navigation pour loader un objet avant dâ€™arriver Ã 
destination
91
COGNITIC
9.6 Resolver
92
1. DÃ©clarer le service de rÃ©solution
et son comportement
2. DÃ©finir la propriÃ©tÃ© â€œresolveâ€ de la
route pour y exposer le service de resolver
et spÃ©cifier un nom pour lâ€™objet rÃ©solu
3. RÃ©cupÃ©rer lâ€™objet rÃ©solu grÃ¢ce Ã 
ActivatedRoute, dans le composant cible
COGNITIC
Exercice
Mettre en place un CRUD de fan de sÃ©rie.
Chaque fan sera dÃ©fini par son nom, sa date de naissance(interdit au moins de 13 ans), et la liste
de leur sÃ©ries prÃ©fÃ©rÃ©es (juste le titre).
Aucune limitation du nombre de sÃ©ries dÃ©finie par lâ€™utilisateur Ã  la crÃ©ation de son profil
Sur la page de modification de profil, il doit Ãªtre possible dâ€™ajouter ou supprimer des sÃ©ries.
- 4 composants (liste des fans, dÃ©tails, crÃ©ation, mise Ã  jour)
- Seule lâ€™annÃ©e est vÃ©rifiÃ©e pour lâ€™Ã¢ge des fans
- Si un champ est visible, il sera obligatoirement rempli
93
COGNITIC
10 Storage
94
COGNITIC
Table des matiÃ¨res
95
Les storages
10.1 LocalStorage vs SessionStorage
10.2 MÃ©thodes associÃ©es
COGNITIC
10.1 DiffÃ©rence entre les deux storages
Le sessionStorage garde les infos voulues jusquâ€™Ã  ce que le navigateur ou lâ€™onglet soit
fermÃ©
Le localStorage quand Ã  lui est disponible jusquâ€™Ã  ce que lâ€™application vide le storage ou
que lâ€™utilisateur vide le cache de son navigateur.
Pour les deux : stockage jusquâ€™Ã  10mo pour la plupart des navigateurs
96
COGNITIC
10.2 MÃ©thodes associÃ©es
97
Quâ€™il sâ€™agisse du local ou du session storage, les commandes
sont identiques. Seul le comportement global est diffÃ©rent
Ajoute un valeur en session (de type string uniquement)
RÃ©cupÃ¨re la valeur stockÃ©e Ã  la clÃ© â€œkeyâ€
Supprime une clÃ© et la valeur associÃ©e de la session
Vide complÃ¨tement la session (clÃ©s et valeurs)
COGNITIC
11 Observable
98
COGNITIC
Table des matiÃ¨res
99
Les observable
11.1 La librairie RXJS
11.2 Subject / BehaviorSubject
11.3 Subscribe()
11.4 Subscription
11.5 OpÃ©rateur RXJS
COGNITIC
11.1 La librairie RXJS
Faisant partie du bundle de base
dâ€™Angular, cette librairie contient tout le
nÃ©cessaire pour gÃ©rer les Observable.
Ceux-ci sont le fondement de la
programmation dite rÃ©active et
permettent en gros, de ne plus avoir Ã 
charger manuellement une valeur si elle
est observÃ©e
100
Au delÃ  de Ã§a, elle permet de gÃ©rer des
comportements asynchrones (appel dâ€™api
par exemple) et amÃ¨ne des outils de gestion
de collection observable
Remarque : Ce chapitre ne couvre pas lâ€™entiÃ¨retÃ© des possibilitÃ©s de
RXJS mais apporte lâ€™essentiel pour la comprÃ©hension des observable
https://www.learnrxjs.io/
COGNITIC
11.2 Subject et BehaviorSubject
101
Pour que plusieurs composants puissent se
baser sur le mÃªme service et donc les mÃªmes
valeurs. Il sera nÃ©cessaire dâ€™utiliser la notion
dâ€™observable.
Nous verrons dans le chapitre suivant que les
appels api (HttpClient) retourne dâ€™office un
observable. Mais dans le cas de propriÃ©tÃ©s ou
dâ€™objets gÃ©rÃ©s par lâ€™application elle-mÃªme, il
faut mettre en place soi-mÃªme cette notion.
Câ€™est lÃ  quâ€™interviennent les Subject
Autre avantage non nÃ©gligeables, nous accÃ©dons Ã  la notion
dâ€™abstraction (plus dâ€™accÃ¨s direct Ã  une propriÃ©tÃ©s) et pouvons dÃ¨s lors
utiliser lâ€™encapsulation de maniÃ¨re efficace.
COGNITIC
11.2 Subject et BehaviorSubject
102
Les types Subject et BehaviorSubject permettent de dâ€™
Ã©mettre la valeur dâ€™une propriÃ©tÃ©s aux diffÃ©rents
composant abonnÃ© Ã  ce subject.
La diffÃ©rence fondamentale entre les deux types est
que le BehaviorSubject Ã©met sa valeur par dÃ©faut lors
de sa construction. Contrairement au Subject.
Pour les deux, Ã  chaque nouvelle modification, il faudra
Ã©mettre la valeur.
Le BehaviorSubject Ã  Ã©galement la particularitÃ© de
garder sa derniÃ¨re valeur Ã©mise en mÃ©moire. Elle est
accessible via la mÃ©thode GetValue()
La mÃ©thode next de mySubject , quâ€™il soit Subject
oÃ¹ BehaviorSubject, enverra la valeur de property Ã 
tous les abonnÃ©s (voir slide suivant)
COGNITIC
11.3 Subscribe
103
Pour suivre lâ€™Ã©volution dâ€™un
observable, il sera nÃ©cessaire de
sâ€™y abonner via la mÃ©thode
subscribe() disponible pour
nâ€™importe quel type observable
La mÃ©thode subscribe() attend jusquâ€™Ã  trois lambas,
1) le paramÃ¨tre dâ€™entrÃ©e reprÃ©sente la valeur Ã©mise par
lâ€™observable. Et dont lâ€™expression reprÃ©sente le traitement
exÃ©cutÃ© Ã  chaque nouvelle Ã©mission de lâ€™observable
2) le paramÃ¨tre dâ€™entrÃ©e reprÃ©sente lâ€™Ã©ventuel erreur
retournÃ©e par lâ€™observable et lâ€™expression, le traitement Ã 
faire en cas dâ€™erreur.
3) ReprÃ©sente lâ€™action Ã  effectuer quâ€™il y ai des erreurs ou pas
Nous pouvons comparer Ã§a Ã  un bloc â€œtry catch finallyâ€
COGNITIC
11.4 Subscription
104
Lâ€™objet Subscription permet de stocker le statut de
la mÃ©thode subscribe() . Ce qui veut dire quâ€™il est
possible dâ€™agir sur cette souscription pour sâ€™en
dÃ©sabonner par exemple.
COGNITIC
11.5 OpÃ©rateurs RXJS
105
Nous sommes capable de nous abonnÃ©s Ã  des
observables. Il temps dâ€™apprendre Ã  sâ€™en servir.
Il est possible dâ€™appliquer diffÃ©rents opÃ©rateurs Ã 
lâ€™observable avant de dÃ©clarer la souscription.
Au travers de la mÃ©thode .pipe()
Ce cours ne couvre pas la liste des opÃ©rateurs.
La liste exhaustive se trouve ici :
https://www.learnrxjs.io/learn-rxjs/operators
COGNITIC
12 HttpClient
106
COGNITIC
Table des matiÃ¨res
107
HttpClient
12.1 Discussion API <-> Angular
12.2 HttpVerbs de base
12.3 Interceptor
COGNITIC
12.1 Api <> Angular
108
La discussion entre API et Angular passe par la le module HttpClient ( => importer HttpClientModule)
API
- Database
- Controller
- Models
- â€¦
Angular
- Services
- Components
- Models
- HttpClient
HttpRequest
HttpResponse
Header, HttpVerb,
Content,...
Header, Status code,
ResponseMessage
Remarque : Chaque action Http retourne un objet de type Observable<T>
COGNITIC
12.2 Http Verbs
109
Verbe UtilitÃ© Exemple Angular
Get RÃ©cupÃ©ration de donnÃ©es
Post Envoi de donnÃ©es (possibilitÃ©
dâ€™en recevoir en retour)
Put Modification de donnÃ©es
Delete Suppression de donnÃ©e
Un paramÃ¨tre optionnel supplÃ©mentaire permet de donner des
infos de header (comme â€œAuthorizationâ€, â€œContent-Typeâ€, â€¦)
Attention:
Sâ€™il y a objet en
httpResponse, il est
nÃ©cessaire de typer
la mÃ©thode en
ajoutant le type
entre chevron
(ex : get<T>)
COGNITIC
12.3 Interceptor
110
Lâ€™objet interceptor va, comme son nom lâ€™indique,
intercepter les requÃªtes Http et les retourner
â€œmodifiÃ©esâ€. Pour, par exemple y inclure des
informations de Header.
Le paramÃ¨tre req correspond Ã  la requÃªte interceptÃ©e, quant au
paramÃ¨tre next, il fait rÃ©fÃ©rence Ã  la requÃªte une fois modifiÃ©e
COGNITIC
12.3 Interceptor (suite)
111
Il faudra ensuite prÃ©ciser au niveau des providers du module la
classe dâ€™intercepteur Ã  utiliser.
provide : prÃ©cise ce qui doit Ãªtre gÃ©rer (ici lâ€™interception HTTP).
useClass : lâ€™instance de classe Ã  utiliser
multi : (true/false par dÃ©faut). DÃ©finit sâ€™il est possible dâ€™avoir
plusieurs instances de la classe en mÃªme temps
COGNITIC
13 Publication
112
COGNITIC
13 Build de lâ€™application
113
Il est trÃ¨s facile de build son application pour
dÃ©ployer sur nâ€™importe quel serveur pouvant
hÃ©berger de lâ€™html.
Il suffit de tapper la commande
ng build
Et dâ€™y ajouter lâ€™option --prod pour minifier le code.
Le build est alors dÃ©poser dans un rÃ©pertoire /dist.
Copiez en le contenu sur votre hÃ©bergeur et le tour
est jouÃ©.
Attention : Si vous ne dÃ©posez pas le projet Ã  la
racine de votre serveur, il faudra spÃ©cifier le
chemin dâ€™accÃ¨s dans le fichier index.html Ã  la
ligne en remplaÃ§ant le / par la route nÃ©cessaire
COGNITIC
Merci pour votre attention!"></textarea
>
&nbsp;&nbsp;&nbsp;ğŸ“
<button
  style="
    display: inline;
    inline-size: 85px;
    block-size: 25px;
    color: white;
    background-color: red;
  "
  onclick="alert('ğŸš« pas autorisÃ©!')"
>
  Delete
</button>
&nbsp;
<button
  style="
    display: inline;
    inline-size: 85px;
    block-size: 25px;
    color: white;
    background-color: rgb(0, 17, 255);
  "
  onclick="alert('ğŸš« pas autorisÃ©!')"
>
  Update
</button>
<p style="color: blue; display: inline">Date: 13/12/2023</p>
<p style="color: rgb(0, 0, 0); display: inline">Ressource.pdf (Algo)</p>
&nbsp;
<a href="assets/pdf/Python%20-%20Base%20(Bstorm).pdf" style="display: inline"
  >Algo</a
>&nbsp;<img src="assets\logo\icone_PDF.jpg" width="2%" />
<!-- Add textarea for the PDF visualization -->
<textarea
  style="
    display: block;
    inline-size: 97%;
    block-size: 50px;
    margin: 10px;
    font-size: 16px;
  "
>
Table des matiÃ¨res â— Variable â— Interaction avec la console â— OpÃ©rateur â—‹ ArithmÃ©tique â—‹ Comparaison â—‹ Logique â— Structure conditionnel â—‹ If â— Structure itÃ©rative â—‹ while â—‹ for
â— Collection â—‹ Tuple â—‹ List â—‹ Dictionaries â—‹ Set â— Les mÃ©thodes â— Gestion des erreurs
2
Brainstorm Consulting
Les variables
3
Brainstorm Consulting
Quâ€™est ce que câ€™est ?
Une variable permet de stocker une information en mÃ©moire, celle-ci se compose :
â— Un nom
â— Un type
â— Une valeur
â— Une rÃ©fÃ©rence mÃ©moire
Le concept de variable constante nâ€™existe pas en python.
4
Brainstorm Consulting
Le nom dâ€™une variable
En python, la convention de nommage pour les variables est le Â« snake_case Â»
â— Peut Ãªtre composÃ© de lettre, chiffre et underscore
â— Commence toujours par une lettre
â— En minuscule
â— Les caractÃ¨res spÃ©ciaux sont interdits (lettres accentuÃ©es, $, #, ... )
5
Brainstorm Consulting
Les mots rÃ©servÃ©s
Attention, il y a des mots-clefs que vous ne pouvez pas utiliser!
Voici la liste des 33 mots rÃ©servÃ©s en python :
6
Brainstorm Consulting
Le type dâ€™une variable
Le python est un langage Ã  typage dynamique.
â— Le type adaptÃ© est automatiquement utilisÃ© lors de lâ€™affectation de la variable.
â— Il est conseillÃ© de ne pas changer le type de variable en cours de programme !
La fonction Â« type(...) Â» permet de rÃ©cupÃ©rer le type de la variable
7
Brainstorm Consulting
Les types de base
â— NumÃ©rique
â—‹ int : Valeur entiÃ¨re
â—‹ float : Valeur approximative dâ€™un nombre rÃ©el
â— Texte
â—‹ str : ChaÃ®ne de caractÃ¨res
â—‹ unicode : ChaÃ®ne de caractÃ¨res encodÃ©s en Unicode
Une valeur de type texte doit Ãªtre en simple ou double quote.
Pour du texte multiligne sans caractÃ¨re d'Ã©chappement, il faut tripler les quotes.
8
Brainstorm Consulting
Les types de base
â— BoolÃ©en
â—‹ bool : Valeur Â« True Â» ou Â« False Â» (Attention, en python, il faut une Majuscule !)
â— Autres types
â—‹ vide : Valeur Â« None Â» (Ã‰quivalent au Â« null Â» de C#, Java, ...)
â—‹ type : Type basique, renvoyÃ© Ã  lâ€™aide de la mÃ©thode type(...)
â—‹ object : Objet basique
â—‹ function : Fonction
Liste complÃ¨te des diffÃ©rents types :
https://fr.wikiversity.org/wiki/Python/Les_types_de_base
9
Brainstorm Consulting
Affectation
Contrairement au langage classiqueâ€¦ il nâ€™est pas nÃ©cessaire de dÃ©clarer les variables.
Lâ€™affectation des variables se rÃ©alise avec l'opÃ©rateur Â« = Â».
Python autorise Ã©galement lâ€™affectation multiple
10
Brainstorm Consulting
Conversion
Il existe des mÃ©thodes permettant de convertir une variable vers un type donnÃ©
â— int(...) : Conversion vers un entier de type â€œintâ€
â— float(...) : Conversion vers un nombre Ã  virgule
â— str(...) : Transformation vers du texte
â— unicode(...) : Transformation vers du texte encodÃ© en Unicode
11
Brainstorm Consulting
Interaction avec la console
12
Brainstorm Consulting
Ecrire dans la console
La fonction a utiliser pour afficher du texte dans la console est Â« print(...) Â»
Lors quâ€™il y a plusieurs valeurs, un sÃ©parateur (espace par dÃ©faut) est ajoutÃ©.
En fin de ligne, un saut de ligne est ajoutÃ©.
13
Brainstorm Consulting
Lire dans la console
Pour interagir avec lâ€™utilisateur, il est possible de lire la saisie de la console.
Pour cela, il faut utiliser la mÃ©thode Â« input(â€œmessageâ€) Â», qui va permet de rÃ©cupÃ©rer la
valeur entrÃ©e par l'utilisateur en format texte.
Attention, la valeur rÃ©cupÃ©rÃ©e sera toujours du type texte,
une conversion est nÃ©cessaire pour la transformer en entier, rÃ©el,...
14
Brainstorm Consulting
Les opÃ©rateurs
15
Brainstorm Consulting
ArithmÃ©tique
Les opÃ©rateurs arithmÃ©tiques sont :
+ Addition
- Soustraction
* Multiplication
/ Division rÃ©el
// Division entiÃ¨re
% Modulo (Reste de la division entiÃ¨re)
16
Brainstorm Consulting
Comparaison
Les opÃ©rateurs de comparaison sont :
== EgalitÃ© strict != DiffÃ©rence
< Strictement supÃ©rieur <= SupÃ©rieur ou Ã©gal
> Strictement infÃ©rieur >= InfÃ©rieur ou Ã©gal
in Test d'adhÃ©sion : Si â€œaâ€ est contenu dans â€œbâ€.
is Test dâ€™identitÃ© : Si â€œaâ€ et â€œbâ€ contiennent sur le mÃªme contenu.
17
Brainstorm Consulting
Logique
Les opÃ©rateurs logiques sont :
and Vrai, si les 2 valeurs sont vraies.
or Vrai, si au moins une des 2 valeurs est vraie.
not Lâ€™inverse de la valeur.
18
Brainstorm Consulting
Affectation et opÃ©ration
Il existe une Ã©criture raccourcie qui permet de rÃ©aliser une opÃ©ration arithmÃ©tique
combinÃ©e avec une affection
a += b â†’ a = a + b
a -= b â†’ a = a - b
a *= b â†’ a = a * b
...
19
Brainstorm Consulting
La structure conditionnelle
20
Brainstorm Consulting
Le Â« if, elif, else Â»
La structure Â« if Â» permet d'exÃ©cuter des opÃ©rations en fonction de condition.
â— if Condition Ã  tester (obligatoire)
â— elif Condition si la prÃ©cÃ©dente est fausse (optionnel et rÃ©pÃ©table)
â— else Traitement si aucune condition validÃ©e (optionnel)
21
Brainstorm Consulting
Les structures itÃ©ratives
22
Brainstorm Consulting
La structure Â« while Â»
La boucle Â« while Â» permet de rÃ©pÃ©ter un ensemble dâ€™opÃ©rations tant que la condition
vÃ©rifiÃ©e est vraie.
Attention, vous devez toujours maÃ®triser la condition de la boucle!
23
Brainstorm Consulting
Les diffÃ©rentes structures Â« for Â»
Les structures Â« for Â» sont les boucles permettant de parcourir les collections.
En python, il en existe 3 cas diffÃ©rents :
â— Utiliser directement avec une collection
â— A lâ€™aide de la mÃ©thode Â« enumerate(...) Â»
â— A lâ€™aide de la mÃ©thode Â« range(...) Â»
Les diffÃ©rentes collections du python seront abordÃ©es par la suite
24
Brainstorm Consulting
Les boucles Â« for Â»
â— Avec une collection
â— MÃ©thode Â« enumerate(collection) Â»
25
Brainstorm Consulting
Les boucles Â« for Â» â— MÃ©thode Â« range(start, stop, step) Â»
Elle est utilisable de 3 maniÃ¨res
diffÃ©rentes : â” Avec tous les paramÃ¨tres â” Avec le â€œstartâ€ et le â€œstopâ€
Le â€œstepâ€ par dÃ©faut est 1
â” Avec uniquement le â€œstopâ€
Le â€œstartâ€ par dÃ©faut est 0
26
Brainstorm Consulting
Les collections
27
Brainstorm Consulting
Les diffÃ©rentes collections du python
Les collections permettent de regrouper dans une seule variable un ensemble
dâ€™informations.
En python, il en existe plusieurs :
28
Nom IndexÃ© OrdonnÃ©e Modifiable Membre dupliquÃ©
List Oui Oui Oui Oui
Tuple Oui Oui Non Oui
Set Non Non Oui Non
Dictionaries Oui Non Oui Non
Brainstorm Consulting
La collection Â« list Â»
En python, une liste s'Ã©crit entre crochet â€œ[ ]â€
29
Brainstorm Consulting
La collection Â« list Â»
30
Brainstorm Consulting
RÃ©cupÃ©rer un range
31
Le langage python permet de rÃ©cupÃ©rer un ensemble dâ€™Ã©lÃ©ment au sein dâ€™une liste.
Brainstorm Consulting
La collection Â« tuple Â»
En python, un tuple s'Ã©crit entre parenthÃ¨se â€œ( )â€
32
Brainstorm Consulting
La collection Â« set Â»
En python, un set s'Ã©crit entre accolade â€œ{ }â€
33
Brainstorm Consulting
La collection Â« set Â»
34
Brainstorm Consulting
La collection Â« Dictionaries Â»
En python, un dictionnaire s'Ã©crit entre accolade avec des combinaisons â€œclef/valeurâ€.
35
Brainstorm Consulting
La collection Â« Dictionaries Â»
36
Brainstorm Consulting
Les mÃ©thodes
37
Brainstorm Consulting
DÃ©finition dâ€™une mÃ©thode
38
L'utilisation des mÃ©thodes permet d'Ã©viter la rÃ©pÃ©tition de codes.
Pour dÃ©clarer une mÃ©thode, il faut utiliser le mot clef Â« def Â».
Il en existe 2 types :
â— ProcÃ©dure â†’ Ne retourne aucune valeur
â— Fonction â†’ Retourne une valeur
La convention de nommage pour les mÃ©thodes est Ã©galement le Â« snake_case Â»
Brainstorm Consulting
Exemple dâ€™une procÃ©dure
39
Brainstorm Consulting
Exemple dâ€™une fonction
40
Brainstorm Consulting
Les paramÃ¨tres
Les valeurs reÃ§ues en paramÃ¨tres sont copiÃ©es dans des variables locales Ã  la mÃ©thode.
41
Brainstorm Consulting
Variable locale VS globale
Les variables crÃ©Ã©es au sein dâ€™une
mÃ©thode nâ€™existe que dans celle-ci.
En python, il est possible dâ€™utiliser le mot
clef Â« global Â» pour crÃ©er ou utiliser une
variable en dehors de la zone mÃ©moire
de la mÃ©thode.
 Attention, ceci n'est pas conseillÃ© !
42
Brainstorm Consulting
Gestion des erreurs
43
Brainstorm Consulting
Try... Except
La gestion des erreurs permet dâ€™intercepter les exceptions pour les traiter.
En python, il y a quatre types de blocs prÃ©vu pour cela : try, except, else et finally.
44
Brainstorm Consulting
Multiples Â« Except Â»
Le bloc Â« Except Â» est spÃ©cialisable pour
gÃ©rer uniquement un type dâ€™erreur.
Il est possible de gÃ©rer plusieurs types
dâ€™erreurs, Ã  lâ€™aide de multiples except.
Dans ce cas, lâ€™exception va passer de
except en except, Ã  la recherche du
premier bloc compatible avec
lâ€™exception.
45
Brainstorm Consulting
Merci pour votre attention.</textarea
>
&nbsp;&nbsp;&nbsp;ğŸ“
<button
  style="
    display: inline;
    inline-size: 85px;
    block-size: 25px;
    color: white;
    background-color: red;
  "
  onclick="alert('ğŸš« pas autorisÃ©!')"
>
  Delete
</button>
&nbsp;
<button
  style="
    display: inline;
    inline-size: 85px;
    block-size: 25px;
    color: white;
    background-color: rgb(0, 17, 255);
  "
  onclick="alert('ğŸš« pas autorisÃ©!')"
>
  Update
</button>
<p style="color: blue; display: inline">Date: 13/12/2023</p>
<p style="color: rgb(0, 0, 0); display: inline">
  Ressource.pdf (SQL procÃ©dural)
</p>
&nbsp;
<a href="assets\pdf\T-SQL - ProcÃ©dural.pdf" style="display: inline"
  >SQL procÃ©dural</a
>&nbsp;<img src="assets\logo\icone_PDF.jpg" width="2%" />
<!-- Add textarea for the PDF visualization -->
<textarea
  style="
    display: block;
    inline-size: 97%;
    block-size: 50px;
    margin: 10px;
    font-size: 16px;
  "
>
Introduction
Pourquoi le T-SQL
FinalitÃ© : le trigger
CaractÃ©ristiques du langages
Lâ€™environnement de dÃ©veloppement
RÃ©ponses du serveur
â€¢ Faire des requÃªtes, câ€™est bien, les automatiser, câ€™est mieux !
> ProcÃ©dures
> Fonctions
> Triggers
> â€¦
â€¢ Langage directement utilisable dans les bases de donnÃ©es, sans
utilisation de langages externes
â€¢ Souvent dÃ©nigrÃ©, car mÃ©connu, mais peut rÃ©ellement allÃ©ger les
codes externes appelant les BD, optimisant grandement le traitement
T-SQL - Introduction CogniTIC 4
T-SQL - Introduction CogniTIC 5
â€¢ Langage construits par Â« blocs Â». La structure Â« BEGIN â€¦ END Â»
viendra dÃ©limiter les instructions telles que Â« IF Â», Â« While Â»,
Â« GOTO Â» et Â« WAITFOR Â»
T-SQL - Introduction CogniTIC 6
T-SQL - Introduction CogniTIC 7
â€¢ Les points-virgules et autres annotations habituelles de
programmation ne sont pas obligatoires, mais ne crÃ©ent pas dâ€™erreur
et permette de dÃ©limiter tout de mÃªme les instructions
â€¢ Donner une en-tÃªte Ã  un ensemble dâ€™instructions permet de crÃ©er
des objets stockÃ©s dans la base de donnÃ©es (procÃ©dures, fonctions,
triggers)
â€¢ En T-SQL, un script est considÃ©rÃ© comme une procÃ©dure anonyme Ã 
part entiÃ¨re. Il nâ€™est donc pas nÃ©cessaire dâ€™Ãªtre dans un bloc
procÃ©dural pour dÃ©clarer des variables, exÃ©cuter des boucles, etc.
â€¢ La commande GO permet de forcer
immÃ©diatement lâ€™exÃ©cution de certaines
instruction dont lâ€™exÃ©cution est lancÃ©e par lots
(comme câ€™est le cas dans les procÃ©dures,
fonctions et triggers, hors manipulations de
transactions)
Sans le GO, le serveur est normalement autorisÃ©
Ã  exÃ©cuter les ordres qui lui sont proposÃ©s
dâ€™exÃ©cuter simultanÃ©ment dans lâ€™ordre quâ€™il le
dÃ©sire
â€¢ Le symbole # prÃ©cÃ¨de toute table temporaire que lâ€™on voudrait utiliser
T-SQL - Introduction CogniTIC 8
â€¢ La commande Â« EXEC Â» permet dâ€™exÃ©cuter une commande
particuliÃ¨re complexe, construite Ã  partir dâ€™un ensemble dâ€™ordre
prÃ©alables et stockÃ©s dans une variable
â€¢ Lâ€™instruction Â« SET Â» permet de donner une valeur aux variables
ainsi que de paramÃ©trer certaines options de la base de donnÃ©es
T-SQL - Introduction CogniTIC 9
â€¢ SQL Server
Management Studio
(client Microsoft pour
son SQL Server) â€¢ ATTENTION Ã 
toujours se positionner
sur la bonne base de
donnÃ©es ! â€¢ Utilisation du bouton
Â« REFRESH Â» pour
faire apparaÃ®tre les
objets crÃ©Ã©s â€¢ Les scripts ne sont
connus du serveur que
lors de leur lecture, ils
ne sont pas stockÃ©s en
tant quâ€™objets !
T-SQL - Introduction CogniTIC 10
â€¢ Lorsquâ€™une requÃªte est envoyÃ©e vers le serveur via lâ€™interface dâ€™
Ã©dition des requÃªtes (New Query), le serveur nous informe du
rÃ©sultat de cette requÃªte, au bas de la page. Un texte en rouge nous
indique une erreur. Double-cliquer sur le texte de lâ€™erreur pour
surligner immÃ©diatement lâ€™endroit oÃ¹ elle a Ã©tÃ© rencontrÃ©e dans le
code.
T-SQL - Introduction CogniTIC 11
â€¢ Il est possible de demander lâ€™affiche dâ€™un texte par le serveur via lâ€™instruction
Â« PRINT Â»
â€¢ Une autre maniÃ¨re de faire peut consister Ã©galement Ã  sÃ©lectionner ce que
lâ€™on dÃ©sire afficher Ã  partir dâ€™une table temporaire. Cependant, ces tables ne
sont utilisables quâ€™une seule fois, il est donc nÃ©cessaire et recommandÃ©, pour
des questions de performance, de les supprimer rapidement. Il est Ã  noter
quâ€™un changement dâ€™utilisateur ou de session supprime ces tables.
T-SQL - Introduction CogniTIC 12
DÃ©finition
Nature des variables
DÃ©claration des variables
Nom des variables
Type des variables
Affecter une valeur
CONVERT et concatÃ©nation
Le type TABLE
Toute donnÃ©e ou groupe de donnÃ©es que lâ€™on dÃ©sire rÃ©fÃ©rencer une ou
plusieurs fois dans le code dâ€™un programme est le plus souvent stockÃ©
dans une Â« enveloppe Â» nommÃ©e qui permet de lâ€™appeler (de lâ€™utiliser)
plus facilement
Cette donnÃ©e stockÃ©e et nommÃ©e est appelÃ© variable
Une variable possÃ¨de une nature, un nom, un type et a une ou plusieurs
valeurs, mÃªme sâ€™il sâ€™agit de la valeur NULL
â€¢ Remarquons bien que lâ€™absence de valeur nâ€™existe pas, cette
absence Ã  lâ€™affichage cache toujours au moins la valeur Â« NULL Â» qui
nâ€™est pas Ã©quivalent Ã  0, qui est une donnÃ©e numÃ©rique rÃ©elle
â€¢ Attention Ã  toujours donnÃ©e un nom concis et clair Ã  vos objets ou
vos variables, cela rendra le code plus facile Ã  comprendre et plus
prÃ©cis !
T-SQL â€“ Les variables CogniTIC 14
â€¢ Variables SCALAIRES
>> Une variable est dite de nature scalaire si elle ne peut
contenir quâ€™une et une seule VALEUR (un chiffre, une chaine de
caractÃ¨res, etc.)
â€¢ Variables COMPOSITES
 >> Une variable est dite composite si elle contient plusieurs
valeurs diffÃ©rentes quâ€™elles soient du mÃªme type ou non.
En T-SQL, il sâ€™agira le plus souvent dâ€™une table temporaire
â€¢ Variables CONTENEUR ou CURSEUR
>> Les curseurs sont des mÃ©canismes de mÃ©moire tampons
permettant d'accÃ©der aux donnÃ©es renvoyÃ©es par une requÃªte et de
parcourir les lignes du rÃ©sultat une par une
â€¢ A noter que le T-SQL nâ€™aborde pas la notion de variable scalaire
CONSTANTE
T-SQL â€“ Les variables CogniTIC 15
â€¢ Pour pouvoir Ãªtre utilisÃ©e, une variable doit Ãªtre dÃ©clarÃ©e, il faut
signaler au systÃ¨me que lâ€™on crÃ©e un conteneur de ce nom que nous
pourrons utiliser
â€¢ La variable crÃ©e nâ€™existe quâ€™au moment oÃ¹ elle est dÃ©clarÃ©e et
utilisÃ©e. Faire tourner un nouveau script ne permet pas dâ€™utiliser les
variables prÃ©cÃ©demment dÃ©clarÃ©es
â€¢ Toute dÃ©claration de variable commence par lâ€™instruction
Â« DECLARE Â». Notez cependant quâ€™une seule instruction
Â« DECLARE Â» peut dÃ©clarer dâ€™un coups plusieurs variables sÃ©parÃ©es
par des virgules
â€¢ Tout nom de variable utilisateur commencera toujours par le
symbole Â« @ Â»
T-SQL â€“ Les variables CogniTIC 16
â€¢ Le nom que vous choisissez pour vos variables est libre tant quâ€™il
respecte les quelques rÃ¨gles suivantes :
>> Maximum 128 caractÃ¨res
>> Ils doivent commencer par une lettre ou un
Â« underscore Â»
>> Les caractÃ¨res spÃ©ciaux, les accents et les espaces
blancs ne sont pas admis
â€¢ Les noms que vous choisissez sont insensibles Ã  la casse, comme la
plupart des mots utilisÃ©s en T-SQL, dâ€™ailleurs
â€¢ Comme Ã©noncÃ© prÃ©cÃ©demment, il est important de garder en
mÃ©moire que les noms les plus concis et clair sont les plus utiles !
T-SQL â€“ Les variables CogniTIC 17
â€¢ Toute variable doit avoir un type
â€¢ Les types utilisÃ©s sont :
>> bit, int, smallint, tinyint, decimal, numeric, money, smallmoney,
float, real, datetime, smalldatetime, timestamp, uniqueidentifier, char,
varchar, text, nchar, nvarchar, ntext, binary, varbinary, image
â€¢ Parmi les plus importants mis en gras ci-dessus :
INT(eger) - dÃ©finit un chiffre entier
DECIMAL(x,y) - dÃ©finit un chiffre dÃ©cimal contenant
maximum x valeurs dont y aprÃ¨s la virgule
DATETIME â€“ une date au format
AAAA-MM-JJ HH:MM:SS.CCC
VARCHAR(X) â€“ une chaine de caractÃ¨res contenant X
caractÃ¨res maximum
T-SQL â€“ Les variables CogniTIC 18
â€¢ Une fois la variable dÃ©clarÃ©e, il faudra utiliser la commande
Â« SET Â» pour lui affecter une valeur. Utilisez lâ€™opÃ©rateur Â« = Â» pour
associer la variable Ã  la sa nouvelle valeur
â€¢ Par dÃ©faut, la valeur dâ€™une variable est Â« NULL Â»
â€¢ Il est possible dâ€™affecter la valeur Â« NULL Â» Ã  une variable
â€¢ Les chaines de caractÃ¨res apparaissent entre simples guillemets
T-SQL â€“ Les variables CogniTIC 19
â€¢ Une autre faÃ§on dâ€™associer une valeur Ã  une variable est dâ€™utiliser
lâ€™opÃ©rateur Â« SELECT @variable = colonne_table FROM â€¦ Â»
Cela permet dâ€™affecter Ã  la variable une valeur issue dâ€™une colonne
dâ€™une table donnÃ©e
Les insertions multiples avec le mÃªme SELECT sont possibles
â€¢ La clause Â« WHERE Â» nâ€™est pas obligatoire, cependant la requÃªte
ne peut renvoyer quâ€™une seule ligne de la table, les variables Ã©tant de
nature scalaire
â€¢ Il est bien entendu indispensable que la variable soit du mÃªme type
que la valeur que lâ€™on dÃ©sire lui associer
T-SQL â€“ Les variables CogniTIC 20
T-SQL â€“ Les variables CogniTIC 21
â€¢ Le CONVERT implicite
>> Si la valeur que lâ€™on dÃ©sire affecter Ã  une variable nâ€™est
pas du mÃªme type que cette variable, SQL Server essayera de
modifier le type de cette valeur pour lâ€™adapter Ã  celui de la variable.
On dit alors quâ€™il y a conversion implicite de la valeur
â€¢ Si la conversion implicite nâ€™est pas possible, le systÃ¨me renverra
une erreur. Si nous savons que cela est toutefois possible, ou afin dâ€™
Ãªtre sÃ»r que le systÃ¨me ne plantera pas, il est possible (et toujours
conseillÃ©) dâ€™effectuer nous-mÃªme la conversion de valeur grÃ¢ce Ã  la
fonction CONVERT
T-SQL â€“ Les variables CogniTIC 22
â€¢ La concatÃ©nation en T-SQL se fait avec lâ€™opÃ©rateur Â« + Â»
Cela peut prÃªter Ã  confusion puisque cet opÃ©rateur est Ã©galement
celui de lâ€™addition. Comme SQL Server privilÃ©giera lâ€™addition dÃ¨s quâ€™il
rencontre un nombre, il faudra chaque fois convertir tous les termes
dâ€™une concatÃ©nation qui ne sont pas des chaines de caractÃ¨res
â€¢ Il est Ã©galement possible en T-SQL, de rÃ©cupÃ©rer un ensemble de
donnÃ©es, issues de lâ€™une ou plusieurs colonnes dâ€™une ou plusieurs
tables de la base de donnÃ©es. Ce procÃ©dÃ© sera Ã©galement utile pour
rÃ©colter des ensembles de donnÃ©es dans nos programmes
â€¢ Ces variables de type Â« TABLE Â» fonctionnent comme les tables
temporaires dont le nom est prÃ©cÃ©dÃ© dâ€™un Â« # Â» (voir
prÃ©cÃ©demment), cependant, elles ont plusieurs avantages :
>> Elles sont automatiquement effacÃ©es aprÃ¨s utilisation
>> Elles requiÃ¨rent moins de traitement et dâ€™espace mÃ©moire que les
tables temporaires
>> Elles sont le seul moyen dâ€™utiliser des ordres DML sur des donnÃ©es
temporaires dans les fonctions, procÃ©dures et triggers
T-SQL â€“ Les variables CogniTIC 23
â€¢ Exemple dâ€™utilisation dâ€™une variable TABLE temporaire
T-SQL â€“ Les variables CogniTIC 24
Fonctionnement
Lâ€™instruction IF
Lâ€™instruction CASE
Lâ€™expression CASE
T-SQL â€“ Conditionnelles CogniTIC 26
â€¢ Les instructions de contrÃ´le conditionnelles et sÃ©quentielles vous
permettent de poser des conditions dans votre code et du lui
imposer de nâ€™exÃ©cuter certaines partie que dans des cas bien
prÃ©cis. Il sâ€™agit le plus souvent de rÃ©agir en fonction du contenu
dâ€™une variable ou du rÃ©sultat dâ€™une expression
â€¢ Les outils dont vous disposerez sont les instructions Â« IF Â» et
Â« CASE Â»
â€¢ La condition dâ€™un IF ou dâ€™un CASE peut Ãªtre une variable
boolÃ©enne, une constante ou encore une expression qui
renvoie lâ€™une des valeurs TRUE, FALSE ou NULL
â€¢ Les instructions exÃ©cutÃ©es lorsque la condition renvoi la valeur
TRUE peuvent Ãªtre aussi multiples que diverses. Il est
Ã©galement possible dâ€™avoir autant dâ€™instructions quâ€™on le
dÃ©sire avant de fermer une conditionnelle ou de passer Ã  la
condition suivante
CogniTIC 27
â€¢ Contrairement Ã  certains langages, la condition du IF en T-SQL
nâ€™est pas obligatoirement mise entre parenthÃ¨ses.
â€¢ Il est cependant conseillÃ©, surtout si la condition est composÃ©e
lâ€™une combinaison de plusieurs conditions, de dÃ©limiter chaque
condition par des parenthÃ¨ses
â€¢ Les instructions exÃ©cutÃ©es SI la condition est vraie (TRUE) sont
placÃ©es entre les balises Â« BEGIN â€¦ END Â» et peuvent Ãªtre aussi
multiples quâ€™on le dÃ©sire
â€¢ Il nâ€™y a pas de clause Â« THEN Â» en T-SQL !
T-SQL â€“ Conditionnelles
â€¢ Si la condition est fausse (FALSE) au nulle (NULL), les instructions
du IF sont ignorÃ©es. Il est alors possible de passer Ã  la clause
Â« ELSE Â», qui signifie Â« sinon, par dÃ©faut â€¦ Â». La clause Â« ELSE Â»
nâ€™est pas du tout obligatoire
T-SQL â€“ Conditionnelles CogniTIC 28
â€¢ Fort semblable au IF, lâ€™instruction CASE permet de sÃ©lectionner
une sÃ©quence dâ€™instructions Ã  exÃ©cuter parmi plusieurs sÃ©quences
proposÃ©es. Le moteur passe en revue les expressions proposÃ©es
une Ã  une et exÃ©cute les instructions pour lesquelles la valeur
de lâ€™expression est validÃ©e
â€¢ On distinguera deux types de CASE : le simple et le
recherchÃ©. Le premier ne prÃ©voit quâ€™une Ã©galitÃ© strictes entre les
valeurs comparÃ©es alors que le second permettra des inÃ©galitÃ©s
mais sera plus long Ã  Ã©crire
T-SQL â€“ Conditionnelles CogniTIC 29
â€¢ Tout comme dans le cas du IF, le CASE (simple ou recherchÃ©) peut
Ã©galement contenir un ESLE qui ne sera exÃ©cutÃ© que si aucune
des possibilitÃ© du CASE nâ€™est abordÃ©e. MÃªme si le ELSE nâ€™est pas
obligatoire, il est toujours conseillÃ© de le spÃ©cifier
â€¢ Un CASE recherchÃ© Ã©value
une liste dâ€™expressions
boolÃ©ennes et, lorsquâ€™elle
trouve une expression qui
renvoie TRUE, exÃ©cute la
sÃ©quences dâ€™instructions
associÃ©e Ã  cette expression
T-SQL â€“ Conditionnelles CogniTIC 30
â€¢ Lâ€™instruction CASE simple Ã©value une
expression et en fonction de son
rÃ©sultat, exÃ©cute la liste dâ€™instructions
associÃ©e
â€¢ Le problÃ¨me avec les instructions case est quâ€™elles sont obligatoirement
utilisÃ©es dans un SELECT et que de ce fait, elles ne nous renvoient aucune
information Ã  moins de stocker le rÃ©sultat de la requÃªte dans une variable
de type TABLE ou encore dans une table temporaire
â€¢ Lâ€™expression CASE va nous permettre de renvoyer lâ€™information dans une
variable donnÃ©e
T-SQL â€“ Conditionnelles CogniTIC 31
Utilisation des boucles
DÃ©finition du curseur
Manipulation des curseurs
Exemple de boucle avec curseur
T-SQL â€“ Boucles et curseurs CogniTIC 33
â€¢ Les boucles sont utiles lorsque vous dÃ©sirez rÃ©pÃ©ter une
instruction un certain nombre de fois, que vous connaissiez ce
nombre ou pas
â€¢ Les boucles peuvent Ãªtre dÃ©composÃ©es en 2 parties distinctes :
>> Les bornes de la boucle
ComposÃ©es de mots rÃ©servÃ©s qui dÃ©marrent et clÃ´turent la
boucle ainsi que dâ€™une condition de sortie
>> Le corps de la boucle
Il sâ€™agit de la sÃ©quence dâ€™ordres exÃ©cutables compris dans
les bornes de la boucle et exÃ©cutÃ©s Ã  chaque itÃ©ration
â€¢ En T-SQL, seule les boucles Â« WHILE Â» seront utilisÃ©es
T-SQL â€“ Boucles et curseurs CogniTIC 34
â€¢ Comme expliquÃ© prÃ©cÃ©demment, les instructions
que lâ€™on dÃ©sire rÃ©pÃ©ter en boucle Ã  lâ€™intÃ©rieur du
Â« WHILE Â» sont indiquÃ©es entre les bornes Â« BEGIN
â€¦ END Â»
â€¢ Une boucle while sâ€™exÃ©cute TANT QUE la
condition de dÃ©part est vraie. Si celle-ci nâ€™est
pas vrai au dÃ©part de la boucle, son contenu
ne sâ€™exÃ©cute mÃªme pas une fois
Il est donc nÃ©cessaire de donner une valeur
de dÃ©part Ã  la condition de la boucle et
sâ€™assurer que la condition devienne fausse au
bout dâ€™un temps
* Les commandes Â« BREAK Â» et
Â« CONTINUE Â» permettent de mettre fin Ã 
une boucle directement ou de continuer le
traitement normalement. Souvent utilisÃ©
avec un IF, bien entendu
Les curseurs sont des mÃ©canismes de mÃ©moire tampons
permettant d'accÃ©der aux donnÃ©es renvoyÃ©es par une requÃªte,
elle-mÃªme pouvant Ãªtre une jointure de deux ou plusieurs tables,
prÃ©sentant Ã©ventuellement plusieurs colonnes
Le gros avantage des curseurs est de permettre de parcourir
lâ€™ensemble des lignes quâ€™il contient, une part une
â€¢ Un curseur doit Ãªtre dÃ©clarÃ© au mÃªme titre quâ€™une variable. Lorsquâ€™il
est dÃ©clarer, il ne constitue quâ€™une rÃ©fÃ©rence qui aidera Ã  le gÃ©nÃ©rer
lorsquâ€™il sera Â« ouvert Â» pour la premiÃ¨re fois, moment auquel le
systÃ¨me rÃ©serve alors de lâ€™espace mÃ©moire pour le curseur
â€¢ Une fois lâ€™utilisation du curseur terminÃ©e, il sera nÃ©cessaire de le
Â« fermer Â» ET de Â« libÃ©rer Â» lâ€™espace mÃ©moire quâ€™il occupait
T-SQL â€“ Boucles et curseurs CogniTIC 35
â€¢ Pour utiliser un curseur prÃ©alablement dÃ©clarer, il faudra utiliser la
commande Â« OPEN nom_curseur Â»
â€¢ Pour extraire une ligne du curseur dans les variables appropriÃ©es,
nous utiliserons la commande
Â« FETCH nom_curseur INTO @varCol1, @varCol2, @varCol3, â€¦ Â»
A chaque fois que cette commande est utilisÃ©e, elle renvoi les
donnÃ©es de la ligne suivante du curseur
â€¢ Pour mettre fin Ã  lâ€™utilisation du curseur, il faudra le fermer en
utilisant la commande Â« CLOSE nom_curseur Â»
â€¢ Fermer un curseur ne libÃ¨re pas lâ€™espace mÃ©moire quâ€™il utilisait, au
cas oÃ¹ il serait ouvert Ã  nouveau et donc, recrÃ©Ã©.
La commande Â« DEALLOCATE nom_curseurÂ» permettra de
supprimer lâ€™espace mÃ©moire que le curseur utilisait
T-SQL â€“ Boucles et curseurs CogniTIC 36
â€¢ Par dÃ©faut, le curseur prendra toujours la ligne SUIVANTE quâ€™il
contient. Il est possible mais non recommander de remonter dâ€™une
ligne dans le curseur, pour des raisons de performance
â€¢ Lorsquâ€™un Â« FETCH Â» rÃ©ussi Ã  rÃ©cupÃ©rer une ligne (câ€™est-Ã -dire quâ€™il
nâ€™est pas arrivÃ© Ã  la fin du curseur) alors la variable globale
Â« @@FETCH_STATUS Â» vaut Â« VRAI Â»
â€¢ La variable Â« @@FETCH_STATUS Â» est bien utile afin de sortir
automatiquement dâ€™une boucle Â« WHILE Â». Cependant, il faudra
penser Ã  faire un Â« FETCH Â» avant lâ€™ouverture de la boucle, pour que
la variable Â« @@FETCH_STATUS Â» soit Â« VRAI Â» au dÃ©part.
T-SQL â€“ Boucles et curseurs CogniTIC 37
T-SQL â€“ Boucles et curseurs CogniTIC 38
Les UDF
Syntaxe
Exemples
Les procÃ©dures
Syntaxe et exemple de procÃ©dure
ParamÃ¨tres
Le paramÃ¨tre OUT(PUT)
ParamÃ¨tres de type TABLE
â€¢ Une fonction est un ensemble dâ€™instructions qui remplissent une
tÃ¢che particuliÃ¨re et surtout, renvoient une valeur !
â€¢ La valeur renvoyÃ©e par la fonction implique que cette fonction
ne peut pas Ãªtre utilisÃ©e seule ou exÃ©cutÃ©e directement, elle
doit faire partie dâ€™une autre instruction T-SQL
â€¢ Il existe deux grands types de fonctions : celles renvoyant
une valeur et celles renvoyant un ensemble de donnÃ©es (une
table donc)
T-SQL â€“ Fonctions et procÃ©dures CogniTIC 40
Une UDF, autrement dit Â« User Define Function Â» ou Fonction
DÃ©finie par l'Utilisateur est un ensemble de commandes regroupÃ©es
sous un mÃªme nom dâ€™objet, que lâ€™on dÃ©fini pour des besoins de
traitements rÃ©currents au sein des requÃªtes et du code des
procÃ©dures stockÃ©es ou des triggers. Elle fait donc partie intÃ©grante
de la base de donnÃ©es, oÃ¹ elle est considÃ©rÃ©e comme un objet Ã 
part entiÃ¨re, au mÃªme titre qu'une table, une vue, un utilisateur ou
une procÃ©dure stockÃ©e.
CogniTIC 41
â€¢ La syntaxe dâ€™une fonction est la suivante. Il est Ã  noter le type dâ€™Ã©lÃ©ment
renvoyÃ© et le mot-clÃ© Â« RETURN Â», obligatoires, dans le code de la fonction
â€¢ Le Â« type_rÃ©sultant Â» est donc un type classique, le mot-clÃ© TABLE ou
encore, une variable de type TABLE que lâ€™on dÃ©fini Ã  cet endroit
â€¢ Il nâ€™est pas possible, au sein du code dâ€™une fonction, dâ€™exÃ©cuter un ordre
DML de manipulation des tables. Cela devra se simuler via une procÃ©dure qui
jouera sur des paramÃ¨tres passÃ©s en mode OUTPUT
T-SQL â€“ Fonctions et procÃ©dures
T-SQL â€“ Fonctions et procÃ©dures CogniTIC 42
â€¢ Une procÃ©dure ne renvoyant aucune valeur peut donc Ãªtre
appelÃ©e comme une commande dans le code. Elle peut Ãªtre
exÃ©cutÃ©e seule, sans interagir avec dâ€™autres Ã©lÃ©ments du code
â€¢ En crÃ©ant des paramÃ¨tre dits Â« de sortie Â» il est possible de
simuler en quelques sortes un retour de valeur pour une
procÃ©dure Ã©galement
CogniTIC 43
Une procÃ©dure est Ã©galement un objet de la base de donnÃ©es,
regroupant un ensemble de commandes qui effectuent une tÃ¢che
particuliÃ¨re le plus souvent, rÃ©currente.
La diffÃ©rence fondamentale entre les procÃ©dures et les fonctions
est quâ€™une procÃ©dure ne renvoi aucune valeur (du moins pas
classiquementâ€¦)
T-SQL â€“ Fonctions et procÃ©dures
T-SQL â€“ Fonctions et procÃ©dures CogniTIC 44
T-SQL â€“ Fonctions et procÃ©dures CogniTIC 45
â€¢ On distingue deux types de paramÃ¨tres
>> Les paramÃ¨tres FORMELS, qui dÃ©signent le nom
gÃ©nÃ©rique par lequel les paramÃ¨tres sont rÃ©fÃ©rencÃ©s dans la
dÃ©claration de la fonction ou procÃ©dure
>> Les paramÃ¨tres RÃ‰ELS, qui reprÃ©sentent la valeur
qui est rÃ©ellement Ã©changÃ©e entre le programme appelant et
la fonction ou la procÃ©dure.
Un paramÃ¨tre est une valeur Ã©ventuellement Ã©changÃ©e entre une
fonction ou une procÃ©dure et le programme appelant
â€¢ Les paramÃ¨tres formels sont dÃ©finis dans le code de crÃ©ation
de la fonction ou de la procÃ©dure et nâ€™ont de signification que dans ce
contexte prÃ©cis
â€¢ Les paramÃ¨tres formels ont un type qui ne peux avoir de
contrainte comme la taille de la chaine de caractÃ¨re (VARCHAR2) ou
du nombre rÃ©el (NUMBER), par exemple
â€¢ Un paramÃ¨tre formel et son paramÃ¨tre rÃ©el correspondant
doivent Ãªtre de mÃªme type
T-SQL â€“ Fonctions et procÃ©dures CogniTIC 46
T-SQL â€“ Fonctions et procÃ©dures CogniTIC 47
â€¢ Les paramÃ¨tres OUTPUT sont des paramÃ¨tres dâ€™une fonction ou procÃ©dure
qui permettent de renvoyer une valeur au programme appelant, mÃªme sâ€™il
sâ€™agit dâ€™une procÃ©dure
â€¢ Pour rÃ©cupÃ©rer la valeur renvoyÃ©e, il nous faudra une variable du mÃªme
type, passÃ©e en paramÃ¨tre de la procÃ©dure ou fonction
â€¢ Dans le cas dâ€™une procÃ©dure, vous DEVREZ utiliser la commande EXECUTE
pour utiliser une procÃ©dure qui demande un paramÃ¨tre en mode OUTPUT
T-SQL â€“ Fonctions et procÃ©dures CogniTIC 48
â€¢ Il est bien entendu possible de passer en paramÃ¨tre une variable de
type table contenant des donnÃ©es, pour, par exemple, faire une
insertion multi-lignes
Loi ACID
CaractÃ©ristiques
Concurrence dâ€™accÃ¨s aux donnÃ©es
SET TRANSACTION
Les verrous
T-SQL â€“ Transactions CogniTIC 50
Toute transaction rÃ©pond obligatoirement Ã  la loi ACID, ce qui
signifie quâ€™elle est :
- ATOMIQUE :: Chacun des changements dâ€™Ã©tat de la transaction
arrive ou aucun nâ€™arrive
- COHÃ‰RENTE :: Une transaction est un changement dâ€™Ã©tat rÃ©ussi
ou annulÃ© ; lâ€™ensemble des actions quâ€™elle comprend respectent
les contraintes dâ€™intÃ©gritÃ© de cet Ã©tat
- ISOLÃ‰E :: Chaque transaction sâ€™exÃ©cute une par une
- DURABLE :: Si une transaction est validÃ©e, elle lâ€™est de maniÃ¨re
permanente et elle survit Ã  tout incident ultÃ©rieur
T-SQL â€“ Transactions CogniTIC 51
â€¢ En T-SQL, la valeur Â« AUTOCOMMIT Â» (validation automatique)
est obligatoirement Ã  ON en permanence. Cela signifie que si on ne lâ€™
Ã©nonce pas explicitement, tout ordre de modification de la base de
donnÃ©es (DDL ou DML) sera une transaction a part entiÃ¨re
â€¢ Cliquer sur le bouton Â« Execute Â» de la console implique autant de
Â« COMMIT Â» (validation) quâ€™il y a dâ€™ordre dans le script. Un ordre qui
Ã©choue met fin Ã  lâ€™exÃ©cution des ordres qui suivent et fait un
Â« ROLLBACK Â» (annulation) du dernier ordre
â€¢ Afin dâ€™Ã©viter un Â« COMMIT Â» automatique de chacun des ordre
dâ€™un script sÃ©parÃ©ment, il faudra commencer lâ€™ensemble de ces ordres
par la commande Â« BEGIN TRANSACTION Â» et les terminer par un
Â« COMMIT Â» ou un Â« ROLLBACK Â»
T-SQL â€“ Transactions CogniTIC 52
â€¢ Il est possible de crÃ©er des points de sauvegarde afin de ne pas
devoir revenir au dÃ©but de la transaction et de faire plutÃ´t un
Â« ROLLBACK TRANSACTION nom_point_sauvegarde Â»
â€¢ Plusieurs sessions utilisateurs peuvent Ãªtre dÃ©marrÃ©es en
parallÃ¨le. Cela implique que plusieurs transactions peuvent entrer en
concurrence pour accÃ©der Ã  la mÃªme information dâ€™une base de
donnÃ©es. Il est par consÃ©quent primordiale que SQL Server puisse
gÃ©rer lâ€™accÃ¨s aux donnÃ©es afin de prÃ©server leur intÃ©gritÃ©
â€¢ Deux type de manipulations sont disponibles afin de gÃ©rer la
concurrence dâ€™accÃ¨s aux donnÃ©es :
>> SET TRANSACTION : dÃ©fini la transaction dans un mode de
lecture spÃ©cifique, qui gÃ¨rera lui-mÃªme les verrous et la visibilitÃ©
des donnÃ©es modifiÃ©es par la transaction
>> Les Â« TableLocks Â» : ce sont des verrous que lâ€™on peut
soi-mÃªme imposer sur un ensemble de donnÃ©es afin quâ€™il ne soit
pas accÃ©dÃ© avant la fin de la transaction en cours
T-SQL â€“ Transactions CogniTIC 53
T-SQL â€“ Transactions CogniTIC 54
â€¢ Lâ€™ordre Â« SET TRANSACTION Â» permet de
modifier la visibilitÃ© et lâ€™accÃ¨s aux donnÃ©es des
tables de la base de donnÃ©es durant une
transaction donnÃ©e
â€¢ Read UNCOMMITTED â€“ Niveau le plus bas (0)
Permet la lecture des objets dâ€™une BD, que
ceux-ci soient en cours de modification ou non,
ou mÃªme sâ€™ils changent dâ€™Ã©tat lors de lâ€™analyse
de la BD. La transaction ignore donc les verrous
posÃ©s par dâ€™autres transactions, bien quâ€™elle ne
puisse les outrepasser. On parlera de donnÃ©es
fantÃ´mes dans ce cas
â€¢ Read COMMITED â€“ Mode par dÃ©faut (Niveau 1)
SpÃ©cifie que les verrous partagÃ©s sont maintenus durant la lecture des donnÃ©es
pour Ã©viter des lectures incorrectes. Les donnÃ©es peuvent nÃ©anmoins Ãªtre
modifiÃ©es avant la fin de la transaction, ce qui donne des lectures non
renouvelÃ©es ou des donnÃ©es fantÃ´mes.
T-SQL â€“ Transactions CogniTIC 55
â€¢ REPEATABLE Read â€“ Niveau 2
Des verrous sont placÃ©s dans toutes les donnÃ©es utilisÃ©es dans une
requÃªte, afin d'empÃªcher les autres utilisateurs de les mettre Ã  jour.
Toutefois, un autre utilisateur peut ajouter de nouvelles lignes
fantÃ´mes dans un jeu de donnÃ©es par un utilisateur ; celles-ci seront
incluses dans des lectures ultÃ©rieures dans la transaction courante.
â€¢ SERIALIZABLE â€“ Niveau 3
Place un verrou sur une plage de donnÃ©es, empÃªchant les autres
utilisateurs de les mettre Ã  jour ou d'insÃ©rer des lignes dans le jeu de
donnÃ©es, jusqu'Ã  la fin de la transaction. Il s'agit du niveau d'isolation
le plus restrictif parmi les quatre niveaux disponibles. Utilisez cette
option uniquement lorsque cela s'avÃ¨re nÃ©cessaire, car la
concurrence d'accÃ¨s est moindre. Cette option a le mÃªme effet que
l'utilisation de l'option HOLDLOCK dans toutes les tables de toutes les
instructions SELECT d'une transaction.
T-SQL â€“ Transactions CogniTIC 56
â€¢ NOLOCK
Dans une commande SELECT uniquement, permet de faire abstraction des
verrous posÃ©s. Cela peut donner des informations fantÃ´mes
â€¢ TABLELOCK
CrÃ©er un verrou sur la table afin dâ€™y empÃªcher toute modification tant que
lâ€™ordre nâ€™est pas terminer
â€¢ HOLDLOCK
Peut Ãªtre rajoutÃ© aux verrous existants afin de demander Ã  ce que le verrou soit
maintenu jusquâ€™Ã  la fin de la transaction. Si tous les objets se retrouvent en
HOLDLOCK dans une transaction, cela correspond au niveau dâ€™isolation
SERIALIZABLE
Liste de lâ€™ensemble des verrous sur le site MSDN
http://msdn.microsoft.com/fr-fr/library/aa213026(v=sql.80).aspx
DÃ©finition
Syntaxes
INSERTED et DELETED
ROLLBACK et COMMIT
RAISERROR et @@EROR
Exemples de triggers DML
Exemples de triggers DDL et LOGON
Fonction UPDATE
T-SQL â€“ Triggers CogniTIC 58
Un trigger est un programme stockÃ© contenant une sÃ©quence
dâ€™instructions qui se dÃ©clenchent automatiquement lorsquâ€™un
ordre particulier (DML, par exemple) sur une table de la base de
donnÃ©es
â€¢ Le T-SQL gÃ¨re des Â« Triggers DML Â», câ€™est-Ã -dire les triggers
liÃ©s aux ordres INSERT, UPDATE, DELETE, liÃ©s Ã  une table ou une
vue, les Â« Triggers DDL Â» appliquÃ©s aux ordres CREATE,
ALTER, DROP, GRANT, DENY, REVOKE ou UPDATE STATISTICS, et
les Â« Triggers Logon Â», dÃ©clenchÃ©s lors de lâ€™authentification au
serveur, avant lâ€™Ã©tablissement des sessions utilisateurs
â€¢ Les Triggers T-SQL ne sont prÃ©vus que pour se dÃ©clencher
aprÃ¨s un ordre SQL (FOR/AFTER) ou Ã  la place de cet ordre
(INSTEAD OF). Les Triggers BEFORE peuvent Ãªtre simulÃ©s,
mais nâ€™existent pas tels quels
T-SQL â€“ Triggers CogniTIC 59
â€¢ SQL Server prÃ©voit de rÃ©cupÃ©rer lâ€™information manipulÃ©e par
lâ€™utilisateur lors de lâ€™action qui a dÃ©clenchÃ© le trigger. Lâ€™information est
rÃ©cupÃ©rÃ©e comme suit :
>> Lors dâ€™un INSERT, il nâ€™existe que la table INSERTED
qui contient les nouvelles donnÃ©es insÃ©rÃ©es
>> Lors dâ€™un DELETE, il nâ€™existe que la table DELETED qui
contient les Ã©lÃ©ment supprimÃ©s
>> Lors dâ€™un UPDATE, il existe simultanÃ©ment les tables
INSERTED et DELETED. La table INSERTED contient les nouvelles
donnÃ©es mises Ã  jour et la table DELETED contient les anciennes
donnÃ©es qui disparaitront
T-SQL â€“ Triggers CogniTIC 60
T-SQL â€“ Triggers CogniTIC 61
â€¢ Ces tables contiennent automatiquement la mÃªme structure que
les tables auxquelles elles sont liÃ©es : si une mise Ã  jour Ã  lieux sur la
table CLIENT, la table INSERTED temporaire aura autant de colonne
que la table CLIENT contiendra les lignes mises Ã  jour
T-SQL â€“ Triggers CogniTIC 62
â€¢ La fonction Â« UPDATE Â» est une fonction que lâ€™on peut utiliser
dans les triggers INSERT et UPDATE et qui permet de vÃ©rifier si
telle ou telle colonne a subit une mise Ã  jour lors de la requÃªte qui a
dÃ©clenchÃ© le trigger
T-SQL â€“ Triggers CogniTIC 63
â€¢ Le but dâ€™un trigger sera bien souvent de vÃ©rifier quâ€™un ordre est
valide et de lâ€™accepter dans la base de donnÃ©es ou le refuser, câ€™estÃ -dire le Â« COMMIT Â» ou plutÃ´t le Â« ROLLBACK Â»
â€¢ En ce qui concerne le Â« COMMIT Â», cela se fera automatiquement,
il nâ€™est donc pas nÃ©cessaire (et mÃªme recommander de ne pas le
faire) dâ€™expliciter un Â« COMMIT Â» dans la transaction, cela lÃ¨vera
une erreur qui annoncera que la transaction sâ€™est terminÃ©e dans le
trigger alors quâ€™elle sera validÃ©e
â€¢ Le Â« ROLLBACK Â» quant Ã  lui sera toujours nÃ©cessaire. Par dÃ©faut,
le Â« ROLLBACK Â» annulera le trigger et lâ€™instruction qui lâ€™ont
dÃ©marrÃ©. Pour nâ€™annuler que les ordres du triggers, il faudra crÃ©er
une transaction explicitement dans le trigger
â€¢ Les ordres de validation du trigger peuvent bien entendu Ãªtre
contenu dans une conditionnelle telle que le IF
â€¢ Lorsque lâ€™on dÃ©sire afficher un message dâ€™erreur ou rÃ©agir par
rapport Ã  une erreur levÃ©e par le systÃ¨me, il faudra utiliser la
commande Â« RAISERROR Â» ou encore la variable globale
Â« @@ERROR Â»
â€¢ Le RAISERROR permet juste lâ€™affichage dâ€™un message dâ€™erreur Ã 
lâ€™utilisateur, en plus du message classique fourni par le systÃ¨me et
dâ€™un numÃ©ro dâ€™erreur. Dans sa forme la plus simple, il sâ€™Ã©crit :
RAISERROR XXXX â€˜message dâ€™erreurâ€™
â€¢ La variable globale Â« @@ERROR Â» renvoie 0 si aucune erreur nâ€™a
Ã©tÃ© levÃ©e par le systÃ¨me. Il es possible de rÃ©agir en fonction de la
variable et de par exemple, faire un ROLLBACK si lâ€™erreur est
survenue
T-SQL â€“ Triggers CogniTIC 64
T-SQL â€“ Triggers CogniTIC 65
T-SQL â€“ Triggers CogniTIC 66 â€¢ Liste des Ã©vÃ¨nements DDL auxquels il est possible lier
les triggers sur la base de donnÃ©es :
http://msdn.microsoft.com/en-us/library/bb522542.aspx</textarea
>
<!--**********************************-->
<!--Ressources.pdf documents formation-->
<!--**********************************-->
<button style="text-align: start" title="document formation.pdf">
  ğŸ’¾&nbsp; Documents pdf (formation professionnelle)
</button>
<div class="column-content">
  &nbsp;&nbsp;&nbsp;ğŸ“
  <button
    style="
      display: inline;
      inline-size: 85px;
      block-size: 25px;
      color: white;
      background-color: red;
    "
    onclick="alert('ğŸš« pas autorisÃ©!')"
  >
    Delete
  </button>
  &nbsp;
  <button
    style="
      display: inline;
      inline-size: 85px;
      block-size: 25px;
      color: white;
      background-color: rgb(0, 17, 255);
    "
    onclick="alert('ğŸš« pas autorisÃ©!')"
  >
    Update
  </button>
  <p style="color: blue; display: inline">Date: 12/12/2023</p>
  <p style="color: rgb(0, 0, 0); display: inline">
    Ressource contrat formation technofutur gosselies
  </p>
  &nbsp;
  <a href="assets\pdf\SZMULIKOWSKI (signÃ© et datÃ©).pdf" style="display: inline"
    >technofutur Gosselies</a
  >&nbsp;<img src="assets\logo\icone_PDF.jpg" width="2%" />
  <!--************************-->
  <!--Ressources data Power BI-->
  <!--************************-->
  <button style="text-align: start" title="consult data_source">
    ğŸ’¾&nbsp;Ressources data
  </button>
  <div class="column-content">
    &nbsp;&nbsp;&nbsp;ğŸ“
    <button
      style="
        display: inline;
        inline-size: 85px;
        block-size: 25px;
        color: white;
        background-color: red;
      "
      onclick="alert('ğŸš« pas autorisÃ©!')"
    >
      Delete
    </button>
    &nbsp;
    <button
      style="
        display: inline;
        inline-size: 85px;
        block-size: 25px;
        color: white;
        background-color: rgb(0, 17, 255);
      "
      onclick="alert('ğŸš« pas autorisÃ©!')"
    >
      Update
    </button>
    <p style="color: blue; display: inline">Date: 11/12/2023</p>
    <p style="color: rgb(0, 0, 0); display: inline">
      Ressource power BI (console de traitement de donnÃ©es)
    </p>
    <a
      href="https://app.powerbi.com/home?experience=power-bi"
      style="display: inline"
      >Dashboard</a
    >&nbsp;â­
  </div>
  &nbsp;&nbsp;&nbsp;ğŸ“
  <button
    style="
      display: inline;
      inline-size: 85px;
      block-size: 25px;
      color: white;
      background-color: red;
    "
    onclick="alert('ğŸš« pas autorisÃ©!')"
  >
    Delete
  </button>
  &nbsp;
  <button
    style="
      display: inline;
      inline-size: 85px;
      block-size: 25px;
      color: white;
      background-color: rgb(0, 17, 255);
    "
    onclick="alert('ğŸš« pas autorisÃ©!')"
  >
    Update
  </button>
  <p style="color: blue; display: inline">Date: 11/12/2023</p>
  <p style="color: rgb(0, 0, 0); display: inline">
    Ressource power BI (Analayse db forem / demandeurs emplois wallonie): &nbsp;
  </p>
  <a
    href="https://app.powerbi.com/home?experience=power-bi"
    style="display: inline"
    >demandeurs emplois wallonie</a
  >&nbsp;
  <br />
  &nbsp;&nbsp;&nbsp;ğŸ“
  <button
    style="
      display: inline;
      inline-size: 85px;
      block-size: 25px;
      color: white;
      background-color: red;
    "
    onclick="alert('ğŸš« pas autorisÃ©!')"
  >
    Delete
  </button>
  &nbsp;
  <button
    style="
      display: inline;
      inline-size: 85px;
      block-size: 25px;
      color: white;
      background-color: rgb(0, 17, 255);
    "
    onclick="alert('ğŸš« pas autorisÃ©!')"
  >
    Update
  </button>
  <p style="color: blue; display: inline">Date: 11/12/2023</p>
  <p style="color: rgb(0, 0, 0); display: inline">
    Ressource power BI (console de traitement de donnÃ©es): &nbsp;
  </p>
  <a
    href="https://app.powerbi.com/groups/me/reports/26ce0a4c-27c2-421e-8ab1-cbe873d58514/ReportSection?experience=power-bi"
    style="display: inline"
    >DonnÃ©es contacts</a
  >&nbsp;
  <br />
  &nbsp;&nbsp;&nbsp;ğŸ“
  <button
    style="
      display: inline;
      inline-size: 85px;
      block-size: 25px;
      color: white;
      background-color: red;
    "
    onclick="alert('ğŸš«pas autorisÃ©!')"
  >
    Delete
  </button>
  &nbsp;
  <button
    style="
      display: inline;
      inline-size: 85px;
      block-size: 25px;
      color: white;
      background-color: rgb(0, 17, 255);
    "
    onclick="alert('ğŸš« pas autorisÃ©!')"
  >
    Update
  </button>
  <p style="color: blue; display: inline">Date: 11/12/2023</p>
  <p style="color: rgb(0, 0, 0); display: inline">
    Ressource power BI (traitement de donnÃ©es e-commerce labo-2020 technofutur):
    &nbsp;
  </p>
  <a
    href="https://app.powerbi.com/groups/me/reports/d7681724-e9bd-4135-89db-cf1958ffcda5/ReportSection?experience=power-bi"
    style="display: inline"
    >DonnÃ©es e-commerce labo-2020 technofutur</a
  >&nbsp;
  <!--**************-->
  <!--ressources url-->
  <!--**************-->
  <button style="text-align: start" title="consult ressource url">
    ğŸ’¾&nbsp;Ressources url
  </button>
  <div class="column-content">
    &nbsp;&nbsp;&nbsp;ğŸ“
    <button
      style="
        display: inline;
        inline-size: 85px;
        block-size: 25px;
        color: white;
        background-color: red;
      "
    >
      Delete
    </button>
    &nbsp;
    <button
      style="
        display: inline;
        inline-size: 85px;
        block-size: 25px;
        color: white;
        background-color: rgb(0, 17, 255);
      "
    >
      Update
    </button>
    <p style="color: blue; display: inline">Date: 11/12/2023</p>
    <p style="color: rgb(0, 0, 0); display: inline">
      Ressource officielle angular: &nbsp; https://angular.io/
    </p>
    <a href="https://angular.io/" style="display: inline">Angular</a>&nbsp;ğŸŒ
    <br />
    <div class="column-content">
      &nbsp;&nbsp;&nbsp;ğŸ“
      <button
        style="
          display: inline;
          inline-size: 85px;
          block-size: 25px;
          color: white;
          background-color: red;
        "
      >
        Delete
      </button>
      &nbsp;
      <button
        style="
          display: inline;
          inline-size: 85px;
          block-size: 25px;
          color: white;
          background-color: rgb(0, 17, 255);
        "
      >
        Update
      </button>
      <p style="color: blue; display: inline">Date: 11/12/2023</p>
      <p style="color: rgb(0, 0, 0); display: inline">
        Ressource officielle NodeJS: &nbsp; https://nodejs.org/en
      </p>
      <a href="https://nodejs.org/en" style="display: inline">NodeJS</a>&nbsp;ğŸŒ
      <br />
    </div>
    <!--*****************************************-->
    <!--Ressources captures projects Angular demo-->
    <!--*****************************************-->
    <button style="text-align: start" title="consult ressource url">
      ğŸ’¾&nbsp;Ressources captures projects Angular / CV
    </button>
    &nbsp;&nbsp;ğŸ“‘<a
      href="assets\Ressources-side\Capture d'Ã©cran 2023-12-09 091736.png"
      style="display: inline"
      >Curriculum Vitae</a
    >
    ğŸï¸&nbsp;<a
      href="assets\Ressources-side\Capture d'Ã©cran 2023-12-10 151148.png"
      style="display: inline"
      >Demo Angular forms-demandeur emploi</a
    >ğŸï¸&nbsp;<a
      href="assets/Ressources-side/Capture d'Ã©cran 2023-12-10 151208.png"
      style="display: inline"
      >Demo Angular forms-authguard</a
    >ğŸï¸&nbsp;<a
      href="assets\Ressources-side\Capture d'Ã©cran 2023-12-10 151625.png"
      style="display: inline"
      >Demo Angular forms-directive</a
    >ğŸï¸&nbsp;<a
      href="assets\Ressources-side\Capture d'Ã©cran 2023-12-10 151558.png"
      style="display: inline"
      >Demo Angular ajout panier avec service</a
    >ğŸï¸&nbsp;<br /><a
      href="assets\Ressources-side\Capture d'Ã©cran 2023-12-10 151538.png"
      style="display: inline"
      >Demo Angular ajout liste fans avec service/interface</a
    >ğŸï¸&nbsp;<a
      href="assets\Ressources-side\Capture d'Ã©cran 2023-12-10 151248.png"
      style="display: inline"
      >Angular chrono</a
    >ğŸï¸&nbsp;<a
      href="assets\Ressources-side\Capture d'Ã©cran 2023-12-09 104941.png"
      style="display: inline"
      >Demo Angular console Power BI mobile</a
    >ğŸï¸&nbsp;<a
      href="assets\My-Project.js\403415714_749209790582041_850742286997544432_n.png"
      style="display: inline"
      >My-Project.JS: Home Page</a
    >ğŸï¸&nbsp;<a
      href="assets\My-Project.js\403403483_2011181992571075_4210447451025628142_n.png"
      style="display: inline"
      >My-Project.JS: Product1</a
    >ğŸï¸&nbsp;<a
      href="assets\My-Project.js\403416136_320600530815641_7771459393434636562_n.png"
      style="display: inline"
      >My-Project.JS: Product2</a
    >ğŸï¸&nbsp;<a
      href="assets\My-Project.js\403417641_1395820304642185_4432834498597874268_n.png"
      style="display: inline"
      >My-Project.JS: Product3</a
    >ğŸï¸&nbsp;<a
      href="assets\My-Project.js\403416174_337702642302025_4194936285091385968_n.png"
      style="display: inline"
      >My-Project.JS: Product4</a
    >&nbsp;
    <!--****************-->
    <!--Ajouter new item-->
    <!-------------------->
    <button style="text-align: start" title="consult project_frontend">
      ğŸ’¾&nbsp;Ressources update: new data
    </button>
  </div>
</div>
